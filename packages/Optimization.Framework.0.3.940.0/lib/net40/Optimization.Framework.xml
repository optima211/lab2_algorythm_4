<?xml version="1.0"?>
<doc>
  <assembly>
    <name>Optimization.Framework</name>
  </assembly>
  <members>
    <member name="T:Optimization.Expression">
      <summary>
            An expression essentially is a tree which stores operators on subtrees which can either be Expressions or Terms themselves
            </summary>
    </member>
    <member name="M:Optimization.Expression.Evaluate(System.Collections.Generic.IDictionary{System.String,System.Double})">
      <summary>
            Evaluates the expression using the specified variable values.
            </summary>
      <param name="variableValues">The variable values.</param>
      <returns />
      <requires inheritedFrom="M:Optimization.Interfaces.IExpression.Evaluate(System.Collections.Generic.IDictionary{System.String,System.Double})" inheritedFromTypeName="IExpression">variableValues != null</requires>
    </member>
    <member name="M:Optimization.Expression.Sum(System.Collections.Generic.IEnumerable{Optimization.Expression})">
      <summary>
            Sums the specified expressions.
            </summary>
      <param name="expressions">The expressions.</param>
      <requires>expressions != null</requires>
      <ensures>(Object)Contract.Result&lt;Expression&gt;() != null</ensures>
    </member>
    <member name="M:Optimization.Expression.Sum(System.Collections.Generic.IEnumerable{System.Double})">
      <summary>
            Sums up the specified values.
            </summary>
      <param name="values">The expressions.</param>
      <returns />
      <requires>values != null</requires>
      <ensures>(Object)Contract.Result&lt;Expression&gt;() != null</ensures>
    </member>
    <member name="M:Optimization.Expression.Sum(System.Collections.Generic.IEnumerable{Optimization.Term})">
      <summary>
            Sums the specified terms.
            </summary>
      <param name="expressions">The terms.</param>
            BMK: variablename: expressions? terms?
        </member>
    <member name="M:Optimization.Expression.Sum(System.Collections.Generic.IEnumerable{Optimization.Variable})">
      <summary>
            Sums the specified variables.
            </summary>
      <param name="variables">The variables.</param>
      <returns />
      <requires>variables != null</requires>
      <ensures>(Object)Contract.Result&lt;Expression&gt;() != null</ensures>
    </member>
    <member name="M:Optimization.Expression.Sum(System.Int32,System.Int32,System.Func{System.Int32,Optimization.Expression})">
      <summary>
            Sums the specified range of expressions.
            </summary>
      <param name="start">The start.</param>
      <param name="count">The count.</param>
      <param name="selector">The selector.</param>
      <returns />
      <requires>selector != null</requires>
      <requires>count &gt;= 0</requires>
      <requires>start&gt;=0</requires>
      <requires>start+count-1&lt;=int.MaxValue</requires>
      <ensures>(Object)Contract.Result&lt;Expression&gt;() != null</ensures>
    </member>
    <member name="M:Optimization.Expression.Sum(System.Int32,System.Int32,System.Func{System.Int32,Optimization.Term})">
      <summary>
            Sums the specified range of terms.
            </summary>
      <param name="start">The start.</param>
      <param name="count">The count.</param>
      <param name="selector">The selector.</param>
      <returns />
      <requires>selector != null</requires>
      <requires>count &gt;= 0</requires>
      <requires>start &gt;= 0</requires>
      <requires>start + count - 1 &lt;= int.MaxValue</requires>
      <ensures>(Object)Contract.Result&lt;Expression&gt;() != null</ensures>
    </member>
    <member name="M:Optimization.Expression.op_Multiply(Optimization.Expression,Optimization.Expression)">
      <summary>
            Implements the operator *.
            </summary>
      <param name="expression">The first expression.</param>
      <param name="expression2">The second expression.</param>
      <returns>The result of the operator.</returns>
      <requires>(Object)expression != null</requires>
      <requires>(Object)expression2 != null</requires>
      <ensures>(Object)Contract.Result&lt;Expression&gt;() != null</ensures>
    </member>
    <member name="M:Optimization.Expression.op_Multiply(System.Double,Optimization.Expression)">
      <summary>
            Implements the operator *.
            </summary>
      <param name="constant">The constant.</param>
      <param name="expression">The expression.</param>
      <returns>The result of the operator.</returns>
      <requires>!object.Equals(expression,null)</requires>
    </member>
    <member name="M:Optimization.Expression.op_Multiply(Optimization.Expression,System.Double)">
      <summary>
            Implements the operator *.
            </summary>
      <param name="expression">The expression.</param>
      <param name="constant">The constant.</param>
      <returns>The result of the operator.</returns>
      <requires>!object.Equals(expression, null)</requires>
      <ensures>(Object)Contract.Result&lt;Expression&gt;() != null</ensures>
    </member>
    <member name="M:Optimization.Expression.op_LessThanOrEqual(Optimization.Expression,System.Double)">
      <summary>
            Implements the operator &lt;=.
            </summary>
      <param name="expression">The expression.</param>
      <param name="constant">The constant.</param>
      <returns>The result of the operator.</returns>
      <requires>!object.Equals(expression, null)</requires>
      <ensures>Contract.Result&lt;Constraint&gt;() != null</ensures>
    </member>
    <member name="M:Optimization.Expression.op_GreaterThanOrEqual(Optimization.Expression,System.Double)">
      <summary>
            Implements the operator &gt;=.
            </summary>
      <param name="expression">The expression.</param>
      <param name="constant">The constant.</param>
      <returns>The result of the operator.</returns>
      <requires>!object.Equals(expression, null)</requires>
      <ensures>Contract.Result&lt;Constraint&gt;() != null</ensures>
    </member>
    <member name="M:Optimization.Expression.op_LessThanOrEqual(Optimization.Expression,Optimization.Expression)">
      <summary>
            Implements the operator &lt;=.
            </summary>
      <param name="expression1">The first expression.</param>
      <param name="expression2">The second expression.</param>
      <returns>The result of the operator.</returns>
      <requires>!object.Equals(expression1, null)</requires>
      <requires>!object.Equals(expression2, null)</requires>
      <ensures>Contract.Result&lt;Constraint&gt;() != null</ensures>
    </member>
    <member name="M:Optimization.Expression.op_Equality(Optimization.Expression,Optimization.Expression)">
      <summary>
            Implements the operator ==.
            </summary>
      <param name="expression1">The first expression.</param>
      <param name="expression2">The second expression.</param>
      <returns>The result of the operator.</returns>
      <requires>!object.Equals(expression1, null)</requires>
      <requires>!object.Equals(expression2, null)</requires>
      <ensures>Contract.Result&lt;Constraint&gt;() != null</ensures>
    </member>
    <member name="M:Optimization.Expression.op_Equality(Optimization.Variable,Optimization.Expression)">
      <summary>
            Creates a new equality constraint
            </summary>
      <param name="variable">The variable.</param>
      <param name="expression">The expression.</param>
      <returns>The a new constraint as the result of the operator.</returns>
      <requires>!object.Equals(expression, null)</requires>
      <requires>!object.Equals(variable, null)</requires>
      <ensures>Contract.Result&lt;Constraint&gt;() != null</ensures>
    </member>
    <member name="M:Optimization.Expression.op_Equality(Optimization.Expression,Optimization.Variable)">
      <requires>!object.Equals(expression, null)</requires>
      <requires>!object.Equals(variable, null)</requires>
      <ensures>Contract.Result&lt;Constraint&gt;() != null</ensures>
    </member>
    <member name="M:Optimization.Expression.op_Inequality(Optimization.Expression,Optimization.Variable)">
      <summary>
            Please construct inequalities using &lt;= and &gt;=
            </summary>
      <param name="variable">The variable.</param>
      <param name="expression">The expression.</param>
      <returns>The result of the operator.</returns>
    </member>
    <member name="M:Optimization.Expression.op_Inequality(Optimization.Variable,Optimization.Expression)">
      <summary>
            Please construct inequalities using &lt;= and &gt;=
            </summary>
      <param name="variable">The variable.</param>
      <param name="expression">The expression.</param>
      <returns>The result of the operator.</returns>
    </member>
    <member name="M:Optimization.Expression.op_Equality(Optimization.Expression,System.Double)">
      <summary>
            Implements the operator ==.
            </summary>
      <param name="expression">The expression.</param>
      <param name="value">The constant.</param>
      <returns>The result of the operator.</returns>
      <requires>!object.Equals(expression, null)</requires>
      <ensures>Contract.Result&lt;Constraint&gt;() != null</ensures>
    </member>
    <member name="M:Optimization.Expression.op_Inequality(Optimization.Expression,System.Double)">
      <summary>
            Please construct inequalities using &lt;= and &gt;=
            </summary>
      <param name="expression">The expression.</param>
      <param name="value">The value.</param>
      <returns>The result of the operator.</returns>
    </member>
    <member name="M:Optimization.Expression.op_Inequality(Optimization.Expression,Optimization.Expression)">
      <summary>
            Please construct inequalities using &lt;= and &gt;=
            </summary>
      <param name="expression">The expression.</param>
      <param name="expression2">The expression2.</param>
      <returns>The result of the operator.</returns>
    </member>
    <member name="M:Optimization.Expression.op_GreaterThanOrEqual(Optimization.Expression,Optimization.Expression)">
      <summary>
            Implements the operator &gt;=.
            </summary>
      <param name="expression1">The first expression.</param>
      <param name="expression2">The second expression.</param>
      <returns>The result of the operator.</returns>
      <requires>!object.Equals(expression1, null)</requires>
      <requires>!object.Equals(expression2, null)</requires>
      <ensures>Contract.Result&lt;Constraint&gt;() != null</ensures>
    </member>
    <member name="M:Optimization.Expression.op_GreaterThanOrEqual(Optimization.Expression,Optimization.Variable)">
      <summary>
            Implements the operator &gt;=.
            </summary>
      <param name="expression">The expression.</param>
      <param name="variable">The variable.</param>
      <returns>The result of the operator.</returns>
      <requires>!object.Equals(expression, null)</requires>
      <requires>!object.Equals(variable, null)</requires>
      <ensures>Contract.Result&lt;Constraint&gt;() != null</ensures>
    </member>
    <member name="M:Optimization.Expression.op_LessThanOrEqual(Optimization.Expression,Optimization.Variable)">
      <summary>
            Implements the operator &lt;=.
            </summary>
      <param name="expression">The expression.</param>
      <param name="variable">The variable.</param>
      <returns>The result of the operator.</returns>
      <requires>!object.Equals(expression, null)</requires>
      <requires>!object.Equals(variable, null)</requires>
      <ensures>Contract.Result&lt;Constraint&gt;() != null</ensures>
    </member>
    <member name="M:Optimization.Expression.op_LessThanOrEqual(Optimization.Variable,Optimization.Expression)">
      <summary>
            Implements the operator &lt;=.
            </summary>
      <param name="variable">The variable.</param>
      <param name="expression">The expression.</param>
      <returns>The result of the operator.</returns>
      <requires>!object.Equals(expression, null)</requires>
      <requires>!object.Equals(variable, null)</requires>
      <ensures>Contract.Result&lt;Constraint&gt;() != null</ensures>
    </member>
    <member name="M:Optimization.Expression.op_LessThanOrEqual(System.Double,Optimization.Expression)">
      <summary>
            Implements the operator &lt;=.
            </summary>
      <param name="constant">The constant.</param>
      <param name="expression">The expression.</param>
      <returns>The result of the operator.</returns>
      <requires>!object.Equals(expression, null)</requires>
      <ensures>Contract.Result&lt;Constraint&gt;() != null</ensures>
    </member>
    <member name="M:Optimization.Expression.op_GreaterThanOrEqual(System.Double,Optimization.Expression)">
      <summary>
            Implements the operator &gt;=.
            </summary>
      <param name="constant">The constant.</param>
      <param name="expression">The expression.</param>
      <returns>The result of the operator.</returns>
      <requires>!object.Equals(expression, null)</requires>
      <ensures>Contract.Result&lt;Constraint&gt;() != null</ensures>
    </member>
    <member name="M:Optimization.Expression.op_GreaterThanOrEqual(Optimization.Variable,Optimization.Expression)">
      <summary>
            Implements the operator &gt;=.
            </summary>
      <param name="variable">The variable.</param>
      <param name="expression">The expression.</param>
      <returns>The result of the operator.</returns>
      <requires>!object.Equals(expression, null)</requires>
      <requires>!object.Equals(variable, null)</requires>
      <ensures>Contract.Result&lt;Constraint&gt;() != null</ensures>
    </member>
    <member name="M:Optimization.Expression.op_Addition(Optimization.Expression,Optimization.Expression)">
      <summary>
            Implements the operator +.
            </summary>
      <param name="expression1">The first expression.</param>
      <param name="expression2">The second expression.</param>
      <returns>The result of the operator.</returns>
      <requires>!object.Equals(expression1, null)</requires>
      <requires>!object.Equals(expression2, null)</requires>
      <ensures>(Object)Contract.Result&lt;Expression&gt;() != null</ensures>
    </member>
    <member name="M:Optimization.Expression.op_Addition(Optimization.Expression,Optimization.Variable)">
      <summary>
            Implements the operator +.
            </summary>
      <param name="expression1">The expression.</param>
      <param name="variable">The variable.</param>
      <returns>The result of the operator.</returns>
      <requires>(Object)expression1 != null</requires>
      <requires>(Object)variable != null</requires>
      <ensures>(Object)Contract.Result&lt;Expression&gt;() != null</ensures>
    </member>
    <member name="M:Optimization.Expression.op_Addition(Optimization.Variable,Optimization.Expression)">
      <summary>
            Implements the operator +.
            </summary>
      <param name="variable">The variable.</param>
      <param name="expression1">The expression.</param>
      <returns>The result of the operator.</returns>
      <requires>variable != null</requires>
      <requires>(Object)expression1 != null</requires>
    </member>
    <member name="M:Optimization.Expression.op_Addition(Optimization.Expression,System.Double)">
      <summary>
             Adds a constant to an expression
            </summary>
      <param name="expression" />
      <param name="constant" />
      <returns />
      <requires>(Object)expression != null</requires>
      <ensures>(Object)Contract.Result&lt;Expression&gt;() != null</ensures>
    </member>
    <member name="M:Optimization.Expression.op_Addition(System.Double,Optimization.Expression)">
      <summary>
             Adds a constant to an expression
            </summary>
      <param name="constant" />
      <param name="expression" />
      <returns />
      <requires>(Object)expression != null</requires>
      <ensures>(Object)Contract.Result&lt;Expression&gt;() != null</ensures>
    </member>
    <member name="M:Optimization.Expression.op_Subtraction(Optimization.Expression,Optimization.Expression)">
      <summary>
            Implements the operator -.
            </summary>
      <param name="expression1">The first expression.</param>
      <param name="expression2">The second expression.</param>
      <returns>The result of the operator.</returns>
      <requires>!expression1.Equals(null)</requires>
      <requires>!expression2.Equals(null)</requires>
      <ensures>(Object)Contract.Result&lt;Expression&gt;() != null</ensures>
    </member>
    <member name="M:Optimization.Expression.op_Subtraction(Optimization.Expression,System.Double)">
      <summary>
            Implements the operator -.
            </summary>
      <param name="expression1">The expression.</param>
      <param name="constant">The constant.</param>
      <returns>The result of the operator.</returns>
      <requires>(Object)expression1 != null</requires>
      <ensures>(Object)Contract.Result&lt;Expression&gt;() != null</ensures>
    </member>
    <member name="M:Optimization.Expression.op_Subtraction(System.Double,Optimization.Expression)">
      <summary>
            Implements the operator -.
            </summary>
      <param name="constant">The constant.</param>
      <param name="expression1">The expression1.</param>
      <returns>
            The result of the operator.
            </returns>
      <requires>(Object)expression1 != null</requires>
      <ensures>(Object)Contract.Result&lt;Expression&gt;() != null</ensures>
    </member>
    <member name="M:Optimization.Expression.op_Subtraction(Optimization.Variable,Optimization.Expression)">
      <summary>
            Implements the operator -.
            </summary>
      <param name="variable">The variable.</param>
      <param name="expression">The expression.</param>
      <returns>The result of the operator.</returns>
      <requires>!object.Equals(expression, null)</requires>
      <requires>!object.Equals(variable, null)</requires>
      <ensures>(Object)Contract.Result&lt;Expression&gt;() != null</ensures>
    </member>
    <member name="M:Optimization.Expression.op_Subtraction(Optimization.Expression,Optimization.Variable)">
      <summary>
            Implements the operator -.
            </summary>
      <param name="expression">The expression.</param>
      <param name="variable">The variable.</param>
      <returns>The result of the operator.</returns>
      <requires>!object.Equals(expression, null)</requires>
      <requires>!object.Equals(variable, null)</requires>
      <ensures>(Object)Contract.Result&lt;Expression&gt;() != null</ensures>
    </member>
    <member name="P:Optimization.Expression.isLinear">
      <summary>
            Gets or sets a value indicating whether this instance is linear.
            </summary>
      <value>
        <c>true</c> if this instance is linear; otherwise, <c>false</c>.</value>
    </member>
    <member name="P:Optimization.Expression.Variables">
      <summary>
            Gets the variables in this expression.
            </summary>
      <value>The variables.</value>
    </member>
    <member name="P:Optimization.Expression.Terms">
      <summary>
            Gets a list of the terms in this expression. It does not contain any operators and does not tell you anything aobut how they are combined with operators.
            </summary>
      <value>The terms.</value>
    </member>
    <member name="P:Optimization.Expression.Constant">
      <summary>
            Gets the constant of this expression.
            </summary>
      <value>The constant.</value>
    </member>
    <member name="P:Optimization.Expression.ExpressionLowerEstimate">
      <summary>
            Gives a lower estimate on the value of an Expression.
            ToDO: Very experimental. Should be able to estimate linear combinations of variables with finite bounds.
            In the default case -infinity is returned!
            </summary>
    </member>
    <member name="P:Optimization.Expression.ExpressionUpperEstimate">
      <summary>
            Gives an upper estimate in the value of an Expression.
            ToDO: Very experimental. Should be able to estimate linear combinations of variables with finite bounds.
            In the default case -infinity is returned!
            </summary>
    </member>
    <member name="T:Optimization.ConstantExpression">
      <summary>
            A ConstantExpression only holds a double value but can be used as part of an expression
            </summary>
    </member>
    <member name="M:Optimization.ConstantExpression.#ctor(System.Double)">
      <summary>
            Initializes a new instance of the <see cref="T:Optimization.ConstantExpression" /> class.
            </summary>
      <param name="value">The value.</param>
    </member>
    <member name="M:Optimization.ConstantExpression.op_Implicit(System.Double)~Optimization.ConstantExpression">
      <summary>
            Performs an implicit conversion from <see cref="T:System.Double" /> to <see cref="T:Optimization.ConstantExpression" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Optimization.ConstantExpression.op_Multiply(System.Double,Optimization.ConstantExpression)">
      <summary>
            Implements the operator *.
            </summary>
      <param name="factor">The factor.</param>
      <param name="expression">The constant expression.</param>
      <returns>A new <see cref="T:Optimization.ConstantExpression" />.</returns>
      <requires>!object.Equals(expression, null)</requires>
      <ensures>(Object)Contract.Result&lt;ConstantExpression&gt;() != null</ensures>
    </member>
    <member name="M:Optimization.ConstantExpression.op_Multiply(Optimization.ConstantExpression,System.Double)">
      <summary>
            Implements the operator *.
            </summary>
      <param name="expression">The expression.</param>
      <param name="factor">The factor.</param>
      <returns>The result of the operator.</returns>
      <requires>!object.Equals(expression, null)</requires>
      <ensures>(Object)Contract.Result&lt;ConstantExpression&gt;() != null</ensures>
    </member>
    <member name="M:Optimization.ConstantExpression.op_Addition(System.Double,Optimization.ConstantExpression)">
      <summary>
            Implements the operator +.
            </summary>
      <param name="constant">The constant.</param>
      <param name="expression">The expression.</param>
      <returns>The result of the operator.</returns>
      <requires>!object.Equals(expression, null)</requires>
      <ensures>(Object)Contract.Result&lt;ConstantExpression&gt;() != null</ensures>
    </member>
    <member name="M:Optimization.ConstantExpression.op_Addition(Optimization.ConstantExpression,System.Double)">
      <summary>
            Implements the operator +.
            </summary>
      <param name="expression">The expression.</param>
      <param name="constant">The constant.</param>
      <returns>The result of the operator.</returns>
      <requires>!object.Equals(expression, null)</requires>
      <ensures>(Object)Contract.Result&lt;ConstantExpression&gt;() != null</ensures>
    </member>
    <member name="M:Optimization.ConstantExpression.op_Subtraction(Optimization.ConstantExpression,System.Double)">
      <summary>
            Implements the operator +.
            </summary>
      <param name="expression">The expression.</param>
      <param name="constant">The constant.</param>
      <returns>The result of the operator.</returns>
      <requires>!object.Equals(expression, null)</requires>
      <ensures>(Object)Contract.Result&lt;ConstantExpression&gt;() != null</ensures>
    </member>
    <member name="M:Optimization.ConstantExpression.op_Subtraction(System.Double,Optimization.ConstantExpression)">
      <summary>
            Implements the operator -.
            </summary>
      <param name="constant">The constant.</param>
      <param name="expression">The expression.</param>
      <returns>The result of the operator.</returns>
      <requires>!object.Equals(expression, null)</requires>
      <ensures>(Object)Contract.Result&lt;ConstantExpression&gt;() != null</ensures>
    </member>
    <member name="M:Optimization.ConstantExpression.op_Implicit(System.Int32)~Optimization.ConstantExpression">
      <summary>
            Performs an implicit conversion from <see cref="T:System.Int32" /> to <see cref="T:Optimization.ConstantExpression" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Optimization.ConstantExpression.ToString">
      <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
      <returns>
            A <see cref="T:System.String" /> that represents this instance.
            </returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object">Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="P:Optimization.ConstantExpression.Constant">
      <summary>
            Gets the constant.
            </summary>
    </member>
    <member name="P:Optimization.ConstantExpression.isLinear">
      <summary>
            Gets or sets a value indicating whether this instance is linear.
            </summary>
      <value>
              Always <c>true</c> because a <see cref="T:Optimization.ConstantExpression" /> is always linear.
            </value>
    </member>
    <member name="P:Optimization.ConstantExpression.Variables">
      <summary>
            Gets the variables. 
            </summary>
      <value>
              Always <c>null</c> because a <see cref="T:Optimization.ConstantExpression" /> has no Variables.
            </value>
    </member>
    <member name="P:Optimization.ConstantExpression.Terms">
      <summary>
            Gets the terms.
            </summary>
      <value>
              Always <c>null</c> because a <see cref="T:Optimization.ConstantExpression" /> has no Terms.
            </value>
    </member>
    <member name="T:Optimization.Constraint">
      <summary>
            Represents an constraint
            </summary>
      <author>lbeckmann</author>
    </member>
    <member name="M:Optimization.Constraint.#ctor(Optimization.Interfaces.IExpression,System.String,System.Double,System.Double,System.Int32)">
      <summary>
            Initializes a new instance of the <see cref="T:Optimization.Constraint" /> class.
            </summary>
      <param name="expression">The expression.</param>
      <param name="name">The name.</param>
      <param name="lowerBound">The lower bound.</param>
      <param name="upperBound">The upper bound.</param>
      <param name="stochasticStage">The stochastic stage of this constraint</param>
    </member>
    <member name="M:Optimization.Constraint.LessThanOrEqual(Optimization.Expression,Optimization.Expression)">
      <summary>
            Compares two expressions whether the first expression is lower or equal the second expression.
            </summary>
      <param name="expression1">The first expression.</param>
      <param name="expression2">The second expression.</param>
      <returns>A <see cref="T:Optimization.Constraint" /> with upper bound of zero</returns>
      <requires>(Object)expression1 != null</requires>
      <requires>(Object)expression2 != null</requires>
    </member>
    <member name="M:Optimization.Constraint.Equals(Optimization.Expression,Optimization.Expression)">
      <summary>
            Compares the specified expressions.
            </summary>
      <param name="expression1">The first expression.</param>
      <param name="expression2">The second expression.</param>
      <returns>A <see cref="T:Optimization.Constraint" /> with lower and upper bound of zero</returns>
      <requires>(Object)expression1 != null</requires>
      <requires>(Object)expression2 != null</requires>
      <ensures>Contract.Result&lt;Constraint&gt;() != null</ensures>
      <ensures description="The lower bound of the constraint is 0">Contract.Result&lt;Constraint&gt;().LowerBound == 0</ensures>
      <ensures description="The upper bound of the constraint is 0">Contract.Result&lt;Constraint&gt;().UpperBound == 0</ensures>
    </member>
    <member name="M:Optimization.Constraint.GreaterThanOrEqual(Optimization.Expression,Optimization.Expression)">
      <summary>
            Compares two expressions whether the first expression is greater or equal the second expression.
            </summary>
      <param name="expression1">The first expression.</param>
      <param name="expression2">The second expression.</param>
      <returns>A <see cref="T:Optimization.Constraint" /> with lower bound of zero</returns>
      <requires>(Object)expression1 != null</requires>
      <requires>(Object)expression2 != null</requires>
      <ensures>Contract.Result&lt;Constraint&gt;()!=null</ensures>
      <ensures description="The lower bound of the constraint is 0">Contract.Result&lt;Constraint&gt;().LowerBound==0</ensures>
    </member>
    <member name="M:Optimization.Constraint.LessThanOrEqual(Optimization.Expression,System.Double)">
      <summary>
            Compares the expression to a constant whether its less or equal.
            </summary>
      <param name="expression1">The expression.</param>
      <param name="constant">The constant.</param>
      <returns>A <see cref="T:Optimization.Constraint" /> with upper bound of zero</returns>
      <requires>(Object)expression1 != null</requires>
      <ensures>Contract.Result&lt;Constraint&gt;() != null</ensures>
      <ensures description="The upper bound of the constraint is 0">Contract.Result&lt;Constraint&gt;().UpperBound == 0</ensures>
    </member>
    <member name="M:Optimization.Constraint.Equals(Optimization.Expression,System.Double)">
      <summary>
            Compares the expression to a constant.
            </summary>
      <param name="expression1">The expression.</param>
      <param name="constant">The constant.</param>
      <returns>A <see cref="T:Optimization.Constraint" /> with lower and upper bound of zero</returns>
      <requires>(Object)expression1 != null</requires>
      <ensures>Contract.Result&lt;Constraint&gt;() != null</ensures>
      <ensures description="The lower bound of the constraint is 0">Contract.Result&lt;Constraint&gt;().LowerBound == 0</ensures>
      <ensures description="The upper bound of the constraint is 0">Contract.Result&lt;Constraint&gt;().UpperBound == 0</ensures>
    </member>
    <member name="M:Optimization.Constraint.GreaterThanOrEqual(Optimization.Expression,System.Double)">
      <summary>
            Compares the expression to a constant whether its greater or equal.
            </summary>
      <param name="expression1">The expression.</param>
      <param name="constant">The constant.</param>
      <returns>A <see cref="T:Optimization.Constraint" /> with lower bound of zero</returns>
      <requires>(Object)expression1 != null</requires>
      <ensures>Contract.Result&lt;Constraint&gt;() != null</ensures>
      <ensures description="The lower bound of the constraint is 0">Contract.Result&lt;Constraint&gt;().LowerBound == 0</ensures>
    </member>
    <member name="M:Optimization.Constraint.ToString">
      <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
      <returns>A <see cref="T:System.String" /> that represents this instance.</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object">Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="P:Optimization.Constraint.StochasticStage">
      <summary>
             StochasticStage this  of this constraint
            </summary>
    </member>
    <member name="P:Optimization.Constraint.Name">
      <summary>
            Unique name of this constraint.
            </summary>
      <value />
    </member>
    <member name="P:Optimization.Constraint.LowerBound">
      <summary>
            Lower bound (left hand side) of this constraint.
            </summary>
      <value />
    </member>
    <member name="P:Optimization.Constraint.UpperBound">
      <summary>
            Upper bound (right hand side) of this constraint.
            </summary>
      <value />
    </member>
    <member name="P:Optimization.Constraint.Expression">
      <summary>
            Expression of this constraint.
            </summary>
      <value />
    </member>
    <member name="T:Optimization.Exporter.ExpressionNormalizer">
      <summary>
             Class used for normalizing an expression.
             ConstantExpressions should be added up or expanded (to show if the expression is linear or quadratic or nonlinear)
             Another goal is to eliminate as many ConstantExpressions as possible.
            </summary>
    </member>
    <member name="M:Optimization.Exporter.ExpressionNormalizer.Visit(Optimization.Interfaces.IExpression)">
      <summary>
            Returns the normalized expression
            </summary>
      <param name="expression">The Optimization.Model.IExpression</param>
      <returns>The normalized expression</returns>
      <requires inheritedFrom="M:Optimization.Interfaces.IExpressionVisitor`1.Visit(Optimization.Interfaces.IExpression)" inheritedFromTypeName="IExpressionVisitor">exp!=null</requires>
    </member>
    <member name="M:Optimization.Exporter.ExpressionNormalizer.VisitIPlus(Optimization.Interfaces.IPlus,System.Double)">
      <summary>
            Normalizes an expression of the type IPlus, multiplied by an external factor.
            </summary>
      <param name="iPlus">The expression of type IPlus</param>
      <param name="extFactor">The external multiplier</param>
      <returns>The normalized expression</returns>
    </member>
    <member name="M:Optimization.Exporter.ExpressionNormalizer.VisitITimes(Optimization.Interfaces.ITimes,System.Double)">
      <summary>
            Normalizes an expression of the type ITimes, multiplied by an external factor.
            </summary>
      <param name="iTimes">The expression of type ITimes</param>
      <param name="extFactor">The external multiplier</param>
      <returns>The normalized expression</returns>
    </member>
    <member name="M:Optimization.Exporter.ExpressionNormalizer.VisitITerm(Optimization.Interfaces.ITerm,System.Double)">
      <summary>
            Returns an ITerm expression, multiplied by the factor (in case the factor is not 0)
            </summary>
      <param name="iTerm">The orignal ITerm</param>
      <param name="factor">The multiplier, default is 0(in this case the original ITerm is returned)</param>
      <returns>The possibly altered ITerm</returns>
    </member>
    <member name="M:Optimization.Exporter.ExpressionNormalizer.VisitIConstantExpression(Optimization.Interfaces.IConstantExpression)">
      <summary>
            Returns the IConstantExpression
            </summary>
      <param name="iConstantExpression">The IConstantExpression</param>
      <returns>The IConstantExpression</returns>
    </member>
    <member name="M:Optimization.Exporter.ExpressionNormalizer.GetTermsToAdd(Optimization.Interfaces.IPlus,System.Collections.Generic.HashSet{Optimization.Interfaces.ITerm}@,System.Collections.Generic.HashSet{Optimization.Interfaces.ITimes}@,System.Collections.Generic.HashSet{Optimization.Interfaces.IPlus}@,System.Double@,System.Double)">
      <summary>
            Returns all expressions of type ITerm, ITimes, IPlus and a factor of type double of an IPlus expression.
            </summary>
      <param name="plusIn">The expression of type IPlus for which all elements should be identified</param>
      <param name="termsOut">A list of expressions of type ITerm contained in the IPlus expression</param>
      <param name="timesOut">A list of expressions of type ITimes contained in the IPlus expression</param>
      <param name="plusOut">A list of expressions of type IPlus contained in the IPlus expression</param>
      <param name="factor">The factor contained in the IPlus expression</param>
      <param name="extFactor">The factor which is multiplied with the whole IPlus expression, if non is specified the default value is 1, so that the expression is not falsified</param>
    </member>
    <member name="M:Optimization.Exporter.ExpressionNormalizer.GetTermsToMult(Optimization.Interfaces.ITimes,System.Collections.Generic.HashSet{Optimization.Interfaces.ITerm}@,System.Collections.Generic.HashSet{Optimization.Interfaces.ITimes}@,System.Collections.Generic.HashSet{Optimization.Interfaces.IPlus}@,System.Double@,System.Double)">
      <summary>
            Returns all expressions of type ITerm, ITimes, IPlus and a factor of type double of an ITimes expression.
            </summary>
      <param name="timesIn">The expression of type ITimes for which all elements should be identified</param>
      <param name="termsOut">A list of expressions of type ITerm contained in the ITimes expression</param>
      <param name="timesOut">A list of expressions of type ITimes contained in the ITimes expression</param>
      <param name="plusOut">A list of expressions of type IPlus contained in the ITimes expression</param>
      <param name="factor">The factor contained in the ITimes expression</param>
      <param name="extFactor">The factor which is multiplied with the whole ITimes expression, if non is specified the default value is 1, so that the expression is not falsified</param>
    </member>
    <member name="M:Optimization.Exporter.ExpressionNormalizer.expandPlus(System.Collections.Generic.HashSet{Optimization.Interfaces.IPlus},System.Collections.Generic.HashSet{Optimization.Interfaces.ITerm})">
      <summary>
            Expands expressions of type ITerm and IPlus and returns an IPlus expression
            </summary>
      <param name="plus">The list of expression of type IPlus</param>
      <param name="terms">The list of expression of type ITerm</param>
      <returns>The expanded expression of type IPlus</returns>
    </member>
    <member name="T:Optimization.Exporter.LPExporter">
      <summary>
            This class can export a model into a stream, using the LP file format.
            </summary>
    </member>
    <member name="M:Optimization.Exporter.LPExporter.#ctor(System.IO.Stream)">
      <summary>
            Creates a new instance of class <see cref="T:Optimization.Exporter.LPExporter" />.
            </summary>
      <param name="filestream">The stream in which the model should be written.</param>
    </member>
    <member name="M:Optimization.Exporter.LPExporter.Write(Optimization.Interfaces.IModel)">
      <summary>
            Delegates to a method for each part of a LP file.
            </summary>
      <param name="model">The model that should be exported.</param>
    </member>
    <member name="M:Optimization.Exporter.LPExporter.ModelName">
      <summary>
            Writes the model name as a comment into the stream.
            </summary>
    </member>
    <member name="M:Optimization.Exporter.LPExporter.Objective">
      <summary>
            Writes the objective into the stream, including name and the corresponding expression.
            </summary>
    </member>
    <member name="M:Optimization.Exporter.LPExporter.Constraints">
      <summary>
            Writes all constraints into the stream, including name, the corresponding expression and the right-hand side.
            Also included are constraints modelling sos3 sets.
            </summary>
    </member>
    <member name="M:Optimization.Exporter.LPExporter.Variables">
      <summary>
            Writes all variables into the stream.
            </summary>
    </member>
    <member name="M:Optimization.Exporter.LPExporter.General">
      <summary>
            Writes all general variables into the stream.
            </summary>
    </member>
    <member name="M:Optimization.Exporter.LPExporter.Binary">
      <summary>
            Writes all binary variables into the strem.
            </summary>
    </member>
    <member name="M:Optimization.Exporter.LPExporter.SOS">
      <summary>
            Writes all variables included in a SOS1 or SOS2 set into the stream.
            SOS 3 is modeled in the "Constraints section".
            </summary>
    </member>
    <member name="M:Optimization.Exporter.LPExporter.End">
      <summary>
            Writes "End" into the stream. Symbolizes the end of the file.
            </summary>
    </member>
    <member name="M:Optimization.Exporter.LPExporter.WriteSOS(System.Collections.Generic.IDictionary{Optimization.Interfaces.IVariable,System.Double},Optimization.SOSType,System.Int32)">
      <summary>
            Method to write all variables of a SOS set into the stream.
            </summary>
      <param name="sosset">The SOS set</param>
      <param name="sosType">The type of the SOS set</param>
      <param name="counter">The i-th element being written into the stream</param>
    </member>
    <member name="M:Optimization.Exporter.LPExporter.OutputLine(System.String)">
      <summary>
            Writes a string into the stream, taking care of the maximal number of characters in a line.
            </summary>
      <param name="line">The string, which should be outputed.</param>
    </member>
    <member name="M:Optimization.Exporter.LPExporter.Output(System.String)">
      <summary>
            Writes a string into the stream, not looking at the maximal number of characters.
            </summary>
      <param name="output">The string, which should be outputed.</param>
    </member>
    <member name="T:Optimization.Exporter.MPSExporter">
      <summary>
            This class can export a model into a stream, using the MPS file format.
            </summary>
    </member>
    <member name="M:Optimization.Exporter.MPSExporter.#ctor(System.IO.Stream)">
      <summary>
            Creates a new instance of class <see cref="T:Optimization.Exporter.MPSExporter" />.
            </summary>
      <param name="filestream">The stream in which the model should be written.</param>
    </member>
    <member name="M:Optimization.Exporter.MPSExporter.Write(Optimization.Interfaces.IModel)">
      <summary>
            Delegates to a method for each section of a MPS file.
            </summary>
      <param name="model">The model that should be exported.</param>
    </member>
    <member name="M:Optimization.Exporter.MPSExporter.NAME">
      <summary>
            Writes the model name into the NAME section into the stream.
            </summary>
    </member>
    <member name="M:Optimization.Exporter.MPSExporter.ROWS">
      <summary>
            Writes all names of all constraints and the objective (row) into the stream, including a type indicating the rhs-type of the constraint or objective.
            For each row the non-zero elements and the corresponding coefficients, the rhs value and the range are saved.
            </summary>
    </member>
    <member name="M:Optimization.Exporter.MPSExporter.COLUMNS">
      <summary>
            Writes for each non-zero element the corresponding rows(constraint or objective) into the stream.
            For integer variables or sos sets a MARKER is used to indicate the meaning, the start and the end.
            </summary>
    </member>
    <member name="M:Optimization.Exporter.MPSExporter.SOSMarker(System.Collections.Generic.IEnumerable{System.Collections.Generic.IDictionary{Optimization.Interfaces.IVariable,System.Double}},Optimization.SOSType)">
      <summary>
            Writes a MARKER block for a sos set into the stream.
            </summary>
      <param name="sosSets">The sos set, which should be outputed.</param>
      <param name="sosType">The sos-type of the sos set.</param>
    </member>
    <member name="M:Optimization.Exporter.MPSExporter.RHS">
      <summary>
            Writes for all constraints the name and the rhs-value into the stream.
            </summary>
    </member>
    <member name="M:Optimization.Exporter.MPSExporter.RANGES">
      <summary>
            Writes the range for each constraint, having an upper and a lower bound, into the stream.
            </summary>
    </member>
    <member name="M:Optimization.Exporter.MPSExporter.BOUNDS">
      <summary>
            Writes for all variales the upper bound or the lower bound or the bound type and the corresponding value into te stream.
            </summary>
    </member>
    <member name="M:Optimization.Exporter.MPSExporter.SOS">
      <summary>
            Writes all members for each SOS2 set into the SOS section into the stream.
            </summary>
    </member>
    <member name="M:Optimization.Exporter.MPSExporter.ENDATA">
      <summary>
            Writes the ENDATA section into the stream, indicating the end of the file.
            </summary>
    </member>
    <member name="M:Optimization.Exporter.MPSExporter.Output(System.String)">
      <summary>
            Writes a string into the stream as bytes.
            </summary>
      <param name="output">The string, which should be outputed.</param>
    </member>
    <member name="T:Optimization.Exporter.LPStringExprVisitor">
      <summary>
            A class taking an IExpression and returning the corresponding representation in LP file format.
            </summary>
    </member>
    <member name="M:Optimization.Exporter.LPStringExprVisitor.#ctor(System.Collections.Generic.IDictionary{System.String,System.String},System.Collections.Generic.HashSet{System.String})">
      <summary>
            Creates a new instance of the <see cref="T:Optimization.Exporter.LPStringExprVisitor" /> class.
            </summary>
      <param name="cutVariableNames">The reference to a Dictionary saving all variables which are truncaded and their original name</param>
      <param name="usedVariableNames">The reference to a List with all variablenames which are already in use.</param>
    </member>
    <member name="M:Optimization.Exporter.LPStringExprVisitor.VisitTerm(Optimization.Interfaces.ITerm)">
      <summary>
            Returns a string representing an ITerm in LP file format.
            </summary>
      <param name="term">The ITerm</param>
      <returns>The string representing the ITerm</returns>
    </member>
    <member name="M:Optimization.Exporter.LPStringExprVisitor.VisitConstant(Optimization.Interfaces.IConstantExpression)">
      <summary>
            Returns a string representing an IConstantExpression in LP file format.
            </summary>
      <param name="constantExpression">The IConstantExpression</param>
      <returns>The string representing the IConstantExpression</returns>
    </member>
    <member name="M:Optimization.Exporter.LPStringExprVisitor.VisitTimes(Optimization.Interfaces.ITimes)">
      <summary>
            Returns a string representing an expression of type ITimes in LP file format.
            </summary>
      <param name="times">The expression of type ITimes</param>
      <returns>The string representing the expression of type ITimes</returns>
    </member>
    <member name="M:Optimization.Exporter.LPStringExprVisitor.VisitPlus(Optimization.Interfaces.IPlus)">
      <summary>
            Returns a string representing an expression of type IPlus in LP file format.
            </summary>
      <param name="plus">The expression of type IPlus</param>
      <returns>The string representing the expression of type IPlus</returns>
    </member>
    <member name="M:Optimization.Exporter.LPStringExprVisitor.TimesScalar(System.Double,Optimization.Interfaces.IExpression)">
      <summary>
            Returns a string representing a scalar product in LP file format.
            </summary>
      <param name="factor">The factor</param>
      <param name="expr">The IExpression</param>
      <returns>The string representing the scalar product</returns>
    </member>
    <member name="M:Optimization.Exporter.LPStringExprVisitor.TimesQuadratic(System.Double,System.String[])">
      <summary>
            Returns a string representing a quadratic expression in LP file format.
            </summary>
      <param name="factor">The factor</param>
      <param name="vars">The names of the variables</param>
      <returns>The string representing the quadratic expression</returns>
    </member>
    <member name="T:Optimization.Model">
      <summary>
            Represents a mathematical model
            </summary>
    </member>
    <member name="M:Optimization.Model.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Optimization.Model" /> class.
            </summary>
    </member>
    <member name="M:Optimization.Model.AddVariable(Optimization.Interfaces.IVariable)">
      <summary>
            Adds <paramref name="variable" /> to this model instance if it is consistent.
            </summary>
      <param name="variable">Variable to add.</param>
      <requires inheritedFrom="M:Optimization.Interfaces.IModel.AddVariable(Optimization.Interfaces.IVariable)" inheritedFromTypeName="IModel">variable != null</requires>
    </member>
    <member name="M:Optimization.Model.AddVariable(System.String,System.Double,System.Double,Optimization.VariableType)">
      <summary>
            Adds a new variable to this model instance if it is consistent.
            </summary>
      <param name="name">Unique name of the new variable.</param>
      <param name="lowerBound">Lower bound of the new variable.</param>
      <param name="upperBound">Upper bound of the new variable.</param>
      <param name="type">Type of the new variable.</param>
    </member>
    <member name="M:Optimization.Model.AddConstraint(Optimization.Interfaces.IConstraint,System.String)">
      <summary>
            Adds <paramref name="constraint" /> to this model instance if it is consistent. If you choose to provide a name, the name of the constraint will be overridden.
            You need to make sure that the name of the constraint is unique.
            </summary>
      <param name="constraint">Constraint to add.</param>
      <param name="name">The name for the constraint</param>
      <requires inheritedFrom="M:Optimization.Interfaces.IModel.AddConstraint(Optimization.Interfaces.IConstraint,System.String)" inheritedFromTypeName="IModel">constraint != null</requires>
    </member>
    <member name="M:Optimization.Model.AddConstraint(System.String,System.Double,System.Double,Optimization.Interfaces.IExpression)">
      <summary>
            Adds a new constraint to this model instance if it is consistent.
            </summary>
      <param name="name">Unique name of the new constraint.</param>
      <param name="lowerBound">Lower bound (left hand side) of the new constraint.</param>
      <param name="upperBound">Upper bound (right hand side) of the new constraint.</param>
      <param name="expression">Expression of the new constraint.</param>
    </member>
    <member name="M:Optimization.Model.AddObjective(Optimization.Interfaces.IObjective)">
      <summary>
            Adds <paramref name="objective" /> to this model instance if it is consistent.
            </summary>
      <param name="objective">Objective to add.</param>
      <requires inheritedFrom="M:Optimization.Interfaces.IModel.AddObjective(Optimization.Interfaces.IObjective)" inheritedFromTypeName="IModel">objective != null</requires>
    </member>
    <member name="M:Optimization.Model.AddObjective(Optimization.Interfaces.IExpression,System.String,Optimization.ObjectiveSense)">
      <summary>
            Adds a new objective to this model instance if it is consistent.
            </summary>
      <param name="expression">Expression of the new objective.</param>
      <param name="name">Unique name of the new objective.</param>
      <param name="sense">Sense of the new objective.</param>
    </member>
    <member name="M:Optimization.Model.AddVariables(System.Collections.Generic.IEnumerable{Optimization.Interfaces.IVariable})">
      <summary>
            Adds a set of variables to this model instance if it is consistent. //TODO: discuss: What do we mean by "consistent"?
            </summary>
      <param name="variables">Set of variables to add.</param>
      <requires inheritedFrom="M:Optimization.Interfaces.IModel.AddVariables(System.Collections.Generic.IEnumerable{Optimization.Interfaces.IVariable})" inheritedFromTypeName="IModel">variables != null</requires>
    </member>
    <member name="M:Optimization.Model.AddConstraints(System.Collections.Generic.IEnumerable{Optimization.Interfaces.IConstraint})">
      <summary>
            Adds a set of constraint to this model instance if it is consistent.
            </summary>
      <param name="constraints">Set of constraints to add.</param>
      <requires inheritedFrom="M:Optimization.Interfaces.IModel.AddConstraints(System.Collections.Generic.IEnumerable{Optimization.Interfaces.IConstraint})" inheritedFromTypeName="IModel">constraints != null</requires>
    </member>
    <member name="M:Optimization.Model.AddObjectives(System.Collections.Generic.IEnumerable{Optimization.Interfaces.IObjective})">
      <summary>
            Adds a set of objectives to this model instance if it is consistent.
            </summary>
      <param name="objectives">Set of objectives to add.</param>
      <requires inheritedFrom="M:Optimization.Interfaces.IModel.AddObjectives(System.Collections.Generic.IEnumerable{Optimization.Interfaces.IObjective})" inheritedFromTypeName="IModel">objectives != null</requires>
    </member>
    <member name="M:Optimization.Model.Clear">
      <summary>
            Removes all variables, constraints, objectives and scenarios from this model instance.
            </summary>
    </member>
    <member name="M:Optimization.Model.ContainsVariable(System.String)">
      <summary>
            Contains this model instance a variable named <paramref name="name" />?
            </summary>
      <param name="name">Name of the variable to search for.</param>
      <returns />
      <requires inheritedFrom="M:Optimization.Interfaces.IModel.ContainsVariable(System.String)" inheritedFromTypeName="IModel">name != null</requires>
    </member>
    <member name="M:Optimization.Model.ContainsConstraint(System.String)">
      <summary>
            Contains this model instance a constraint named <paramref name="name" />?
            </summary>
      <param name="name">Name of the constraint to search for.</param>
      <returns />
      <requires inheritedFrom="M:Optimization.Interfaces.IModel.ContainsConstraint(System.String)" inheritedFromTypeName="IModel">name != null</requires>
    </member>
    <member name="M:Optimization.Model.ContainsObjective(System.String)">
      <summary>
            Contains this model instance an objective named <paramref name="name" />?
            </summary>
      <param name="name">Name of the objective to search for.</param>
      <returns />
      <requires inheritedFrom="M:Optimization.Interfaces.IModel.ContainsObjective(System.String)" inheritedFromTypeName="IModel">name != null</requires>
    </member>
    <member name="M:Optimization.Model.GetVariable(System.String)">
      <summary>
            Returns the variable named <paramref name="name" />, or <c>null</c> if this model instance contains no such variable.
            </summary>
      <param name="name">Name of the variable to search for.</param>
      <returns />
      <requires inheritedFrom="M:Optimization.Interfaces.IModel.GetVariable(System.String)" inheritedFromTypeName="IModel">name != null</requires>
    </member>
    <member name="M:Optimization.Model.GetConstraint(System.String)">
      <summary>
            Returns the constraint named <paramref name="name" />, or <c>null</c> if this model instance contains no such constraint.
            </summary>
      <param name="name">Name of the constraint to search for.</param>
      <returns />
      <requires inheritedFrom="M:Optimization.Interfaces.IModel.GetConstraint(System.String)" inheritedFromTypeName="IModel">name != null</requires>
    </member>
    <member name="M:Optimization.Model.GetObjective(System.String)">
      <summary>
            Returns the objective named <paramref name="name" />, or <c>null</c> if this model instance contains no such objective.
            </summary>
      <param name="name">Name of the objective to serach for.</param>
      <returns />
      <requires inheritedFrom="M:Optimization.Interfaces.IModel.GetObjective(System.String)" inheritedFromTypeName="IModel">name != null</requires>
    </member>
    <member name="M:Optimization.Model.RemoveVariable(System.String)">
      <summary>
            Removes the variable named <paramref name="name" /> from this model instance, or does nothing if this model instance contains no such variable.
            </summary>
      <param name="name">Name of the variable to remove.</param>
      <requires inheritedFrom="M:Optimization.Interfaces.IModel.RemoveVariable(System.String)" inheritedFromTypeName="IModel">name != null</requires>
    </member>
    <member name="M:Optimization.Model.RemoveConstraint(System.String)">
      <summary>
            Removes the constraint named <paramref name="name" /> from this model instance, or does nothing if this model instance contains no such constraint.
            </summary>
      <param name="name">Name of the constraint to remove.</param>
      <requires inheritedFrom="M:Optimization.Interfaces.IModel.RemoveConstraint(System.String)" inheritedFromTypeName="IModel">name != null</requires>
    </member>
    <member name="M:Optimization.Model.RemoveObjective(System.String)">
      <summary>
            Removes the objective named <paramref name="name" /> from this model instance, or does nothing if this model instance contains no such objective.
            </summary>
      <param name="name">Name of the objective to remove.</param>
      <requires inheritedFrom="M:Optimization.Interfaces.IModel.RemoveObjective(System.String)" inheritedFromTypeName="IModel">name != null</requires>
    </member>
    <member name="M:Optimization.Model.RemoveVariables(System.Collections.Generic.IEnumerable{System.String})">
      <summary>
            Removes a set of variables from this model instance.
            </summary>
      <param name="names">Names of the variables to remove.</param>
      <requires inheritedFrom="M:Optimization.Interfaces.IModel.RemoveVariables(System.Collections.Generic.IEnumerable{System.String})" inheritedFromTypeName="IModel">names != null</requires>
    </member>
    <member name="M:Optimization.Model.RemoveConstraints(System.Collections.Generic.IEnumerable{System.String})">
      <summary>
            Removes a set of constraints from this model instance.
            </summary>
      <param name="names">Names of the constraints to remove.</param>
      <requires inheritedFrom="M:Optimization.Interfaces.IModel.RemoveConstraints(System.Collections.Generic.IEnumerable{System.String})" inheritedFromTypeName="IModel">names != null</requires>
    </member>
    <member name="M:Optimization.Model.RemoveObjectives(System.Collections.Generic.IEnumerable{System.String})">
      <summary>
            Removes a set of objectives from this model instance.
            </summary>
      <param name="names">Names of the objectives to remove.</param>
      <requires inheritedFrom="M:Optimization.Interfaces.IModel.RemoveObjectives(System.Collections.Generic.IEnumerable{System.String})" inheritedFromTypeName="IModel">names != null</requires>
    </member>
    <member name="M:Optimization.Model.Load(System.IO.Stream)">
      <summary>
            Loads the specified file.
            </summary>
      <param name="filestream">The filestream.</param>
      <requires inheritedFrom="M:Optimization.Interfaces.IModel.Load(System.IO.Stream)" inheritedFromTypeName="IModel">filestream!=null</requires>
    </member>
    <member name="M:Optimization.Model.Write(System.IO.Stream,Optimization.FileType)">
      <summary>
            Writes the model to the specified filestream.
            </summary>
      <param name="filestream">The filestream.</param>
      <param name="fileType">Type of the file.</param>
      <requires inheritedFrom="M:Optimization.Interfaces.IModel.Write(System.IO.Stream,Optimization.FileType)" inheritedFromTypeName="IModel">filestream != null</requires>
    </member>
    <member name="M:Optimization.Model.AddSOS1(System.Collections.Generic.IDictionary{Optimization.Interfaces.IVariable,System.Double})">
      <summary>
            Adds an SOS1 constraint
            </summary>
      <param name="variables">The variables.</param>
    </member>
    <member name="M:Optimization.Model.AddSOS2(System.Collections.Generic.IDictionary{Optimization.Interfaces.IVariable,System.Double})">
      <summary>
            Adds an SOS2 constraint
            </summary>
      <param name="variables">The variables.</param>
    </member>
    <member name="M:Optimization.Model.AddSOS3(System.Collections.Generic.IDictionary{Optimization.Interfaces.IVariable,System.Double})">
      <summary>
            Adds an SOS3 constraint
            </summary>
      <param name="variables">The variables.</param>
    </member>
    <member name="M:Optimization.Model.automaticAddingOfVariables(Optimization.Interfaces.IExpression)">
      <requires>expression != null</requires>
      <requires>expression.Variables != null</requires>
    </member>
    <member name="M:Optimization.Model.automaticRemovingOfVariables(Optimization.Interfaces.IExpression)">
      <requires>expression != null</requires>
      <requires>expression.Variables != null</requires>
    </member>
    <member name="M:Optimization.Model.AddSOS(System.Collections.Generic.IDictionary{Optimization.Interfaces.IVariable,System.Double},Optimization.SOSType)">
      <summary>
            Adds an SOS Constraint of the given SOSType
            </summary>
      <param name="variables">The variables.</param>
      <param name="type">The type.</param>
    </member>
    <member name="M:Optimization.Model.Ceil(Optimization.Interfaces.IExpression)">
      <summary>
            Returns an Expression object respresenting the ceil roundoff of the specified expression.
            </summary>
      <param name="expression">The expression.</param>
      <returns />
    </member>
    <member name="M:Optimization.Model.Floor(Optimization.Interfaces.IExpression)">
      <summary>
            Returns an Expression object respresenting the floor roundoff of the specified expression.
            </summary>
      <param name="expression">The expression.</param>
      <returns />
    </member>
    <member name="M:Optimization.Model.Abs(Optimization.Interfaces.IExpression,System.Double)">
      <summary>
            Returns an Expression object respresenting the absolute value of the specified expression.
            </summary>
      <param name="expression">The expression.</param>
      <param name="bigM">Large number, only used if the bounds of the variables of the expressions are non-finite</param>
      <returns />
    </member>
    <member name="M:Optimization.Model.Min(System.Collections.Generic.IEnumerable{Optimization.Interfaces.IExpression},System.Double)">
      <summary>
            Returns an Expression object respresenting the minimum of the specified expressions.
            </summary>
      <param name="expressions">The expressions.</param>
      <param name="bigM">Large number, only used if the bounds of the variables of the expressions are non-finite</param>
      <returns />
    </member>
    <member name="M:Optimization.Model.Max(System.Collections.Generic.IEnumerable{Optimization.Interfaces.IExpression},System.Double)">
      <summary>
            Returns an Expression object representing the maximum of the specified expresssions.
            </summary>
      <param name="expressions">The expressions.</param>
      <param name="bigM">Large number, only used if the bounds of the variables of the expressions are non-finite</param>
      <returns />
    </member>
    <member name="P:Optimization.Model.Name">
      <summary>
            Name of this model instance.
            </summary>
      <value />
    </member>
    <member name="P:Optimization.Model.ModelBehavior">
      <summary>
            Gets or sets the behavior of the model. Available options are "Automatic" and "Manual"
            In automatic mode, the model takes care of adding and removing variables when constraints and objectives get added. In manual mode you need to take care of this yourself.
            </summary>
      <value>
            The model behavior.
            </value>
    </member>
    <member name="P:Optimization.Model.Variables">
      <summary>
            Variables in this model instance.
            </summary>
      <value />
    </member>
    <member name="P:Optimization.Model.SOS1Sets">
      <summary>
            Sets of SOS1 variables in this model instance.
            </summary>
      <value />
    </member>
    <member name="P:Optimization.Model.SOS2Sets">
      <summary>
            Sets of SOS2 variables in this model instance.
            </summary>
      <value />
    </member>
    <member name="P:Optimization.Model.SOS3Sets">
      <summary>
            Sets of SOS3 variables in this model instance.
            </summary>
      <value />
    </member>
    <member name="P:Optimization.Model.Constraints">
      <summary>
            Constraints in this model instance.
            </summary>
      <value />
    </member>
    <member name="P:Optimization.Model.Objectives">
      <summary>
            Objectives in this model instance.
            </summary>
      <value />
    </member>
    <member name="P:Optimization.Model.VariablesCount">
      <summary>
            Count of variables in this model instance.
            </summary>
      <value />
    </member>
    <member name="P:Optimization.Model.ConstraintsCount">
      <summary>
            Count of constraints in this model instance.
            </summary>
      <value />
    </member>
    <member name="P:Optimization.Model.ObjectivesCount">
      <summary>
            Count of objectives in this model instance.
            </summary>
      <value />
    </member>
    <member name="P:Optimization.Model.AreAllVariablesBinary">
      <summary>
            Are all variables in this model instance of type integer and their lower bound equal to zero and their upper bound equal to 1?
            </summary>
      <value />
    </member>
    <member name="P:Optimization.Model.AreAllVariablesInteger">
      <summary>
            Are all variables in this model instance of type integer?
            </summary>
      <value />
    </member>
    <member name="P:Optimization.Model.AreAllVariablesContinuous">
      <summary>
            Are variables in this model instance of type continuous?
            </summary>
      <value />
    </member>
    <member name="P:Optimization.Model.AreAllConstraintsLinear">
      <summary>
            Have all constraints in this model instance linear expressions?
            </summary>
      <value />
    </member>
    <member name="P:Optimization.Model.AreAllObjectivesLinear">
      <summary>
            Have all objectives in this model instance linear expressions?
            </summary>
      <value />
    </member>
    <member name="T:Optimization.ModelTransformation">
      <summary>
            A ModelTransformation offers functionality to transform a model that contains special OperatorExpressions 
            as, e.g., Max,Min,Abs,Floor,Ceil  into a model where these expressions vanish in the sense that they are modelled
             through new variables and constraints.
            This transformation may re-establish linearity of the model.
            TODO: implement a  handling of minmax or maxmin cases in ojectives and constraints. 
            --&gt; Store objective type as global variable and make a distinction of cases!!!
            TODO: This class is not very general, i.e., the interface concept is internally not in use.
            --&gt; This class may also contain some dirty casts : Isomething -&gt; something!
            </summary>
    </member>
    <member name="F:Optimization.ModelTransformation.internalmodel">
      <summary>
            global variable for the changed model that will be returned by Transform(IModel)
            </summary>
    </member>
    <member name="M:Optimization.ModelTransformation.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Optimization.ModelTransformation" /> class.
            </summary>
    </member>
    <member name="M:Optimization.ModelTransformation.Transform(Optimization.Interfaces.IModel)">
      <summary>
            Transform the input model containing OperatorExpressions as, e.g., Min into a new model where these expressions are 
            replaced by new variables and constraints. This means that in the original model also some implicit variables marking 
            new representing variables are set. Modelbehavior of the resulting model is set to Auto.
            </summary>
      <param name="originalmodel">The original model</param>
      <returns>The new model</returns>
    </member>
    <member name="M:Optimization.ModelTransformation.TransformConstraint(Optimization.Interfaces.IConstraint)">
      <summary>
            Transforms a single constraint recursively by replacing special operator expressions by new variables and
             adding new constraints to internalmodel. 
            </summary>
      <param name="constraint">The constraint</param>
      <returns>The constraint with replaced components</returns>
    </member>
    <member name="M:Optimization.ModelTransformation.TransformObjective(Optimization.Interfaces.IObjective)">
      <summary>
            Transforms a single objective recursively by replacing special operator expressions by new variables and
             adding new constraints to internalmodel. 
            </summary>
      <param name="objective">The objective</param>
      <returns>The objective with replaced components</returns>
    </member>
    <member name="M:Optimization.ModelTransformation.Visit(Optimization.Interfaces.IExpression)">
      <summary>
            Visitor for expressions, i.e., here the expression of a constraint is walked through recursively and replacements 
            are performed
            </summary>
      <param name="exp">The expression</param>
      <returns>The expression with replaced components</returns>
    </member>
    <member name="M:Optimization.ModelTransformation.VisitPlus(Optimization.Interfaces.IPlus)">
      <summary>
            Visitor for Plus
            </summary>
      <param name="plus">A Plus OperatorExpression</param>
      <returns>A Plus-Expression with replaced components</returns>
    </member>
    <member name="M:Optimization.ModelTransformation.VisitTimes(Optimization.Interfaces.ITimes)">
      <summary>
            Visitor for Times.
            </summary>
      <param name="times">A Times OperatorExpression</param>
      <returns>A Times-Expression with replaced components </returns>
    </member>
    <member name="M:Optimization.ModelTransformation.VisitConstant(Optimization.Interfaces.IConstantExpression)">
      <summary>
            Visitor for Constant. This method is just a dummy and returns the input.
            </summary>
      <param name="constantExpression">the constant expression</param>
      <returns>the input constantExpression</returns>
    </member>
    <member name="M:Optimization.ModelTransformation.VisitITerm(Optimization.Interfaces.ITerm)">
      <summary>
            Visitor for Term. This method is just a dummy and returns the input
            </summary>
      <param name="term">the term</param>
      <returns>the input term</returns>
    </member>
    <member name="M:Optimization.ModelTransformation.VisitMax(Optimization.Interfaces.IMax)">
      <summary>
            Visit a Max OperatorExpression and replace it by a new variable and the constraints that will
            be included in internalmodel. The representing variable of the Max object will be set and in case of a max of more than
            two expressions a reformulation in terms of a recursion of two-arguments max-expressions is performed. 
            TODO: For the resulting implicit max-Expressions only the representing variable on the highest level is stored yet
            ---&gt; find a solution telling the user about every new variable . 
            </summary>
      <param name="max">The Max object</param>
      <returns>The expression with replaced terms</returns>
    </member>
    <member name="M:Optimization.ModelTransformation.maxOfAllowedExpressionsDC(Optimization.Variable,System.Collections.Generic.IEnumerable{Optimization.Interfaces.IExpression},System.Double)">
      <summary>
            Helper routine for VisitMax. recursivley reformulate z = max(argumentexpressions) by a divide and conquer Ansatz
            until only max-expressions of two arguments are left. If possible, bounds on the 
            representing variables are inherited from the corresponding expressions. If not :
            Attention: Any expression that can not be estimated by finite bounds will receive bounds double.NegativeInfinity and 
            double.PositiveInfinity.
            Todo: In that case the new constraints will work with the constants +/- double.MaxValue!!!
            ToDo: Using skip and take for the division is dirty. IEnumerable does not guarantee ordering 
            -&gt; potentially use Except to make sure no element was used twice
            </summary>
      <param name="z">the representing variable for the max object in this call</param>
      <param name="argumentexpressions">the arguments of the corresponding max in this call</param>
      <param name="bigM">Large number, used if the bounds of the variables of the expressions are non-finite</param>
    </member>
    <member name="M:Optimization.ModelTransformation.VisitMin(Optimization.Interfaces.IMin)">
      <summary>
            Visit a Min OperatorExpression and replace it by a new variable and the constraints that will
            be included in internalmodel. The representing variable of the Min object will be set and in case of a min of more than
            two expressions a reformulation in terms of a recursion of two-arguments min-expressions is performed. 
            TODO: For the resulting implicit min-Expressions only the representing variable on the highest level is stored yet
            ---&gt; find a solution telling the user about every new variable . 
            </summary>
      <param name="min">The Min object</param>
      <returns>The expression with replaced terms</returns>
    </member>
    <member name="M:Optimization.ModelTransformation.minOfAllowedExpressionsDC(Optimization.Variable,System.Collections.Generic.IEnumerable{Optimization.Interfaces.IExpression},System.Double)">
      <summary>
            Helper routine for VisitMin. recursivley reformulate z = min(argumentexpressions) by a divide and conquer Ansatz
            until only min-expressions of two arguments are left. If possible, bounds on the 
            representing variables are inherited from the corresponding expressions. If not :
            Attention: Any expression that can not be estimated by finite bounds will receive bounds double.NegativeInfinity and 
            double.PositiveInfinity.
            Todo: In that case the new constraints will work with the constants +/- double.MaxValue!!!
            ToDo: Using skip and take for the division is dirty. IEnumerable does not guarantee ordering -&gt; potentially use Except to make sure no element was used twice
            </summary>
      <param name="z">the representing variable for the min object in this call</param>
      <param name="argumentexpressions">the arguments of the corresponding min in this call</param>
      <param name="bigM">Large number, used if the bounds of the variables of the expressions are non-finite</param>
    </member>
    <member name="M:Optimization.ModelTransformation.VisitAbs(Optimization.Interfaces.IAbs)">
      <summary>
            Visit an Abs OperatorExpression and replace it by a new variable and the constraints that will
            be included in internalmodel. The representing variable of the Abs object will be set.
            If possible, bounds on the representing variable are inherited from the corresponding expression. 
            Todo: Attention: In case of infinite bounds, constraints are added with double.MaxValue instead of infinite constants
            </summary>
      <param name="abs">The Abs object</param>
      <returns>The expression with replaced terms</returns>
    </member>
    <member name="M:Optimization.ModelTransformation.VisitFloor(Optimization.Interfaces.IFloor)">
      <summary>
            Visit a Floor OperatorExpression and replace it by a new variable and the constraints that will
            be included in internalmodel. The representing variable of the Floor object will be set
            </summary>
      <param name="floor">The Floor object</param>
      <returns>The expression with replaced terms</returns>
    </member>
    <member name="M:Optimization.ModelTransformation.VisitCeil(Optimization.Interfaces.ICeil)">
      <summary>
            Visit a Ceil OperatorExpression and replace it by a new variable and the constraints that will
            be included in internalmodel. The representing variable of the Ceil object will be set
            </summary>
      <param name="ceil">The ceil object</param>
      <returns>The expression with replaced terms</returns>
    </member>
    <member name="T:Optimization.Objective">
      <summary>
            Represents an objective
            </summary>
      <author>lbeckmann</author>
    </member>
    <member name="M:Optimization.Objective.#ctor(Optimization.Interfaces.IExpression,System.String,Optimization.ObjectiveSense)">
      <summary>
            Initializes a new instance of the <see cref="T:Optimization.Objective" /> class.
            </summary>
      <param name="expression">The expression.</param>
      <param name="name">The name.</param>
      <param name="sense">The sense.</param>
    </member>
    <member name="P:Optimization.Objective.Name">
      <summary>
            Unique name of this objective.
            </summary>
      <value />
    </member>
    <member name="P:Optimization.Objective.Sense">
      <summary>
            Sense of this objective.
            </summary>
      <value />
    </member>
    <member name="P:Optimization.Objective.Expression">
      <summary>
            Expression of this objective.
            </summary>
      <value />
    </member>
    <member name="T:Optimization.OperatorExpression">
      <invariant>_expressions!=null</invariant>
      <invariant>Expressions!=null</invariant>
      <invariant description="An Expression must not be null">_expressions.Count(x =&gt; x == null) == 0</invariant>
    </member>
    <member name="M:Optimization.OperatorExpression.#ctor(System.Collections.Generic.IEnumerable{Optimization.Interfaces.IExpression},System.Int32,System.Int32)">
      <summary>
            Initializes a new instance of the <see cref="T:Optimization.Expression" /> class.
            </summary>
      <param name="expressions">The expressions.</param>
      <param name="min">The minimal number of elements in expressions</param>
      <param name="max">The maximal number of elements in expressions</param>
      <requires exception="T:System.ArgumentOutOfRangeException">expressions != null</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">expressions == null</exception>
      <requires description="You provided less than the neccessary number of operands" exception="T:System.ArgumentOutOfRangeException">expressions.Count() &gt;= min</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">!(expressions.Count() &gt;= min)</exception>
      <requires description="You provided more than the allowed number of operands" exception="T:System.ArgumentOutOfRangeException">expressions.Count() &lt;= max</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">!(expressions.Count() &lt;= max)</exception>
    </member>
    <member name="P:Optimization.OperatorExpression.Variables">
      <summary>
            Gets the variables.
            </summary>
    </member>
    <member name="P:Optimization.OperatorExpression.Terms">
      <summary>
            Gets the terms.
            </summary>
      <value>The terms.</value>
    </member>
    <member name="T:Optimization.Operators.Abs">
      <summary>
            Represents the Operator for an absolute value
            </summary>
    </member>
    <member name="M:Optimization.Operators.Abs.#ctor(Optimization.Interfaces.IExpression,System.Double)">
      <summary>
            Initializes a new instance of the <see cref="T:Optimization.Operators.Abs" /> class.
            </summary>
      <param name="expression">An expression.</param>
      <param name="bigM">Large number, only used if the bounds of the variables of the expressions are non-finite</param>
    </member>
    <member name="M:Optimization.Operators.Abs.Evaluate(System.Collections.Generic.IEnumerable{Optimization.Interfaces.IExpression},System.Collections.Generic.IDictionary{System.String,System.Double})">
      <summary>
            Evaluates the specified expressions.
            </summary>
      <param name="expressions">The expressions.</param>
      <param name="variableValues">The variable values.</param>
      <returns />
    </member>
    <member name="P:Optimization.Operators.Abs.BigM">
      <summary>
            A number which is used transforming the abs-expression into expressions, which can be handled by the solvers.
            It should be choosen large enough, so that the solution space is not cut. 
            But choosing this value too large, it can cause numerical errors.
            It's not used in cases, where only terms are used as operators, containing variables with finite bounds. 
            </summary>
    </member>
    <member name="P:Optimization.Operators.Abs.RepresentingVariable">
      <summary>
            A variable that can later be set to the representing variable when a model transformation for removing Abs- 
            expressions is applied.  
            </summary>
    </member>
    <member name="P:Optimization.Operators.Abs.isLinear">
      <summary>
            Gets a value indicating whether this operator always preserves linearity when used with linear expressions. Linearity can be 
            re-established when modelling through linear constraints with new variables.
            </summary>
      <value>
        <c>true</c> if linearity is preserved otherwise, <c>false</c>.</value>
    </member>
    <member name="P:Optimization.Operators.Abs.PreservesLinearity">
      <summary>
            Gets a value indicating whether this operator always preserves linearity when used with terms. Linearity can be
            re-established when modelling through linear constraints with new variables.
            </summary>
      <value>
        <c>true</c> if linearity is preserved otherwise, <c>false</c>.</value>
    </member>
    <member name="T:Optimization.Operators.Ceil">
      <summary>
            Represents the Operator for a ceil roundoff
            </summary>
    </member>
    <member name="M:Optimization.Operators.Ceil.#ctor(Optimization.Interfaces.IExpression)">
      <summary>
            Initializes a new instance of the <see cref="T:Optimization.Operators.Ceil" /> class.
            </summary>
      <param name="expression">An expression.</param>
    </member>
    <member name="M:Optimization.Operators.Ceil.Evaluate(System.Collections.Generic.IEnumerable{Optimization.Interfaces.IExpression},System.Collections.Generic.IDictionary{System.String,System.Double})">
      <summary>
            Evaluates the specified expressions.
            </summary>
      <param name="expressions">The expressions.</param>
      <param name="variableValues">The variable values.</param>
      <returns />
    </member>
    <member name="P:Optimization.Operators.Ceil.RepresentingVariable">
      <summary>
            A variable that can later be set to the representing variable when a model transformation for removing Ceil- 
            expressions is applied.  
            </summary>
    </member>
    <member name="P:Optimization.Operators.Ceil.isLinear">
      <summary>
            Gets a value indicating whether this operator always preserves linearity when used with linear expressions. Linearity can be 
            re-established when modelling through linear constraints with a new variable.
            </summary>
      <value>
        <c>true</c> if linearity is preserved otherwise, <c>false</c>.</value>
    </member>
    <member name="P:Optimization.Operators.Ceil.PreservesLinearity">
      <summary>
            Gets a value indicating whether this operator always preserves linearity when used with terms. Linearity can be 
            re-established when modelling through constraints with new variables.
            </summary>
      <value>
        <c>true</c> if linearity is preserved otherwise, <c>false</c>.</value>
    </member>
    <member name="T:Optimization.Operators.Floor">
      <summary>
            Represents the Operator for a floor roundoff
            </summary>
    </member>
    <member name="M:Optimization.Operators.Floor.#ctor(Optimization.Interfaces.IExpression)">
      <summary>
            Initializes a new instance of the <see cref="T:Optimization.Operators.Floor" /> class.
            </summary>
      <param name="expression">An expression.</param>
    </member>
    <member name="M:Optimization.Operators.Floor.Evaluate(System.Collections.Generic.IEnumerable{Optimization.Interfaces.IExpression},System.Collections.Generic.IDictionary{System.String,System.Double})">
      <summary>
            Evaluates the specified expressions.
            </summary>
      <param name="expressions">The expressions.</param>
      <param name="variableValues">The variable values.</param>
      <returns />
    </member>
    <member name="P:Optimization.Operators.Floor.RepresentingVariable">
      <summary>
            A variable that can later be set to the representing variable when a model transformation for removing Floor- 
            expressions is applied.  
            </summary>
    </member>
    <member name="P:Optimization.Operators.Floor.isLinear">
      <summary>
            Gets a value indicating whether this operator always preserves linearity when used with linear expressions. Linearity can be 
            re-established when modelling through linear constraints with a new variable.
            </summary>
      <value>
        <c>true</c> if linearity is preserved otherwise, <c>false</c>.</value>
    </member>
    <member name="P:Optimization.Operators.Floor.PreservesLinearity">
      <summary>
            Gets a value indicating whether this operator always preserves linearity when used with terms. Linearity can be 
            re-established when modelling through constraints with new variables.
            </summary>
      <value>
        <c>true</c> if linearity is preserved otherwise, <c>false</c>.</value>
    </member>
    <member name="T:Optimization.Operators.Max">
      <summary>
            Represents the Operator for a maximum
            </summary>
    </member>
    <member name="M:Optimization.Operators.Max.#ctor(System.Collections.Generic.IEnumerable{Optimization.Interfaces.IExpression},System.Double)">
      <summary>
            Initializes a new instance of the <see cref="T:Optimization.Operators.Max" /> class.
            </summary>
      <param name="expressions">The expressions.</param>
      <param name="bigM">Large number, only used if the bounds of the variables of the expressions are non-finite</param>
      <requires>expressions != null</requires>
    </member>
    <member name="M:Optimization.Operators.Max.Evaluate(System.Collections.Generic.IEnumerable{Optimization.Interfaces.IExpression},System.Collections.Generic.IDictionary{System.String,System.Double})">
      <summary>
            Evaluates the specified expressions.
            </summary>
      <param name="expressions">The expressions.</param>
      <param name="variableValues">The variable values.</param>
      <returns />
    </member>
    <member name="P:Optimization.Operators.Max.BigM">
      <summary>
            A number which is used transforming the max-expression into expressions, which can be handled by the solvers.
            It should be choosen large enough, so that the solution space is not cut. 
            But choosing this value too large, it can cause numerical errors.
            It's not used in cases, where only terms are used as operators, containing variables with finite bounds. 
            </summary>
    </member>
    <member name="P:Optimization.Operators.Max.RepresentingVariable">
      <summary>
            A variable that can later be set to the representing variable when a model transformation for removing Max- 
            expressions is applied.  
            </summary>
    </member>
    <member name="P:Optimization.Operators.Max.isLinear">
      <summary>
            Gets a value indicating whether this operator always preserves linearity when used with linear expressions. Linearity can 
            be re-established when modelling through linear constraints with new variables, i.e., z=max(expression1,expression2) and w \in \{ 0,1\} 
            for two expressions 
            </summary>
      <value>
        <c>true</c> if linearity is preserved otherwise, <c>false</c>.</value>
    </member>
    <member name="P:Optimization.Operators.Max.PreservesLinearity">
      <summary>
            Gets a value indicating whether this operator always preserves linearity when used with terms. Linearity can be  
            re-established when modelling through linear constraints with new variables, i.e., z=max(expression1,expression2) and w \in \{ 0,1\}
            for two expresssions 
            </summary>
      <value>
        <c>true</c> if linearity is preserved otherwise, <c>false</c>.</value>
    </member>
    <member name="T:Optimization.Operators.Min">
      <summary>
            Represents the Operator for a minimum
            </summary>
    </member>
    <member name="M:Optimization.Operators.Min.#ctor(System.Collections.Generic.IEnumerable{Optimization.Interfaces.IExpression},System.Double)">
      <summary>
            Initializes a new instance of the <see cref="T:Optimization.Operators.Min" /> class. 
            </summary>
      <param name="expressions">The expressions.</param>
      <param name="bigM">Large number, only used if the bounds of the variables of the expressions are non-finite</param>
      <requires>expressions != null</requires>
    </member>
    <member name="M:Optimization.Operators.Min.Evaluate(System.Collections.Generic.IEnumerable{Optimization.Interfaces.IExpression},System.Collections.Generic.IDictionary{System.String,System.Double})">
      <summary>
            Evaluates the specified expressions.
            </summary>
      <param name="expressions">The expressions.</param>
      <param name="variableValues">The variable values.</param>
      <returns />
    </member>
    <member name="P:Optimization.Operators.Min.BigM">
      <summary>
            A number which is used transforming the min-expression into expressions, which can be handled by the solvers.
            It should be choosen large enough, so that the solution space is not cut. 
            But choosing this value too large, it can cause numerical errors.
            It's not used in cases, where only terms are used as operators, containing variables with finite bounds. 
            </summary>
    </member>
    <member name="P:Optimization.Operators.Min.RepresentingVariable">
      <summary>
            A variable that can later be set to the representing variable when a model transformation for removing Min- 
            expressions is applied.  
            </summary>
    </member>
    <member name="P:Optimization.Operators.Min.isLinear">
      <summary>
            Gets a value indicating whether this operator always preserves linearity when used with linear expressions. Linearity can be re-established 
            when modelling through linear constraints with new variables, i.e., z=min(expression1,expression2) and w \in \{ 0,1\} 
            for two expressions.   
            </summary>
      <value>
        <c>true</c> if linearity is preserved otherwise, <c>false</c>.</value>
    </member>
    <member name="P:Optimization.Operators.Min.PreservesLinearity">
      <summary>
            Gets a value indicating whether this operator always preserves linearity when used with terms. Linearity can be 
            re-established when modelling through linear constraints with new variables, i.e., z=min(expression1,expression2) and w \in \{ 0,1\}
            for two expresssions 
            </summary>
      <value>
        <c>true</c> if linearity is preserved otherwise, <c>false</c>.</value>
    </member>
    <member name="T:Optimization.Operators.Plus">
      <summary>
            Represents the Operator for an addition
            </summary>
    </member>
    <member name="M:Optimization.Operators.Plus.#ctor(System.Collections.Generic.IEnumerable{Optimization.Interfaces.IExpression})">
      <summary>
            Initializes a new instance of the <see cref="T:Optimization.Operators.Plus" /> class.
            </summary>
      <param name="expressions">The expressions.</param>
      <requires>expressions!=null</requires>
    </member>
    <member name="M:Optimization.Operators.Plus.#ctor(Optimization.Term,Optimization.Term)">
      <summary>
            Initializes a new instance of the <see cref="T:Optimization.Operators.Plus" /> class.
            </summary>
      <param name="term1">The first term.</param>
      <param name="term2">The second term.</param>
    </member>
    <member name="M:Optimization.Operators.Plus.Evaluate(System.Collections.Generic.IEnumerable{Optimization.Interfaces.IExpression},System.Collections.Generic.IDictionary{System.String,System.Double})">
      <summary>
            Evaluates the specified expressions.
            </summary>
      <param name="expressions">The expressions.</param>
      <param name="variableValues">The variable values.</param>
      <returns />
    </member>
    <member name="M:Optimization.Operators.Plus.ToString">
      <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
      <returns>
            A <see cref="T:System.String" /> that represents this instance.
            </returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object">Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="M:Optimization.Operators.Plus.op_Addition(Optimization.Operators.Plus,Optimization.Expression)">
      <summary>
            Implements the operator +.
            </summary>
      <param name="plus">The plus.</param>
      <param name="expression">The expression.</param>
      <returns>The result of the operator.</returns>
      <requires>!object.Equals(expression, null)</requires>
      <requires>!object.Equals(plus, null)</requires>
      <requires>plus.Expressions != null</requires>
    </member>
    <member name="M:Optimization.Operators.Plus.op_Addition(Optimization.Expression,Optimization.Operators.Plus)">
      <summary>
            Implements the operator +.
            </summary>
      <param name="expression">The expression.</param>
      <param name="plus">The plus.</param>
      <returns>The result of the operator.</returns>
      <requires>!object.Equals(expression, null)</requires>
      <requires>!object.Equals(plus, null)</requires>
      <requires>plus.Expressions!=null</requires>
    </member>
    <member name="M:Optimization.Operators.Plus.op_Addition(Optimization.Operators.Plus,Optimization.Term)">
      <summary>
            Implements the operator +.
            </summary>
      <param name="plus">The plus.</param>
      <param name="term">The term.</param>
      <returns>The result of the operator.</returns>
      <requires>(object)plus!=null</requires>
      <requires>(object)term!=null</requires>
      <requires>plus.Expressions!=null</requires>
    </member>
    <member name="M:Optimization.Operators.Plus.op_Addition(Optimization.Term,Optimization.Operators.Plus)">
      <summary>
            Implements the operator +.
            </summary>
      <param name="term">The term.</param>
      <param name="plus">The plus.</param>
      <returns>The result of the operator.</returns>
      <requires>!object.Equals(term, null)</requires>
      <requires>!object.Equals(plus, null)</requires>
      <requires>plus.Expressions != null</requires>
    </member>
    <member name="M:Optimization.Operators.Plus.op_Addition(Optimization.Operators.Plus,Optimization.Operators.Plus)">
      <summary>
            Implements the operator +.
            </summary>
      <param name="plus1">The first plus.</param>
      <param name="plus2">The second plus.</param>
      <returns>The result of the operator.</returns>
      <requires>!object.Equals(plus1, null)</requires>
      <requires>!object.Equals(plus2, null)</requires>
      <requires>plus1.Expressions != null</requires>
      <requires>plus2.Expressions != null</requires>
    </member>
    <member name="P:Optimization.Operators.Plus.isLinear">
      <summary>
            Gets a value indicating whether this instance is linear.
            </summary>
      <value>
        <c>true</c> if this instance is linear; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Optimization.Operators.Plus.PreservesLinearity">
      <summary>
            Gets a value indicating whether this operator always preserves linearity when used with terms.
            </summary>
      <value>
        <c>true</c> if linearity is preserved otherwise, <c>false</c>.</value>
    </member>
    <member name="T:Optimization.Operators.Times">
      <summary>
            Represents the Operator for a multiplication
            </summary>
    </member>
    <member name="M:Optimization.Operators.Times.#ctor(System.Collections.Generic.IEnumerable{Optimization.Interfaces.IExpression})">
      <summary>
            Initializes a new instance of the <see cref="T:Optimization.Operators.Times" /> class.
            </summary>
      <param name="expressions">The expressions.</param>
    </member>
    <member name="M:Optimization.Operators.Times.Evaluate(System.Collections.Generic.IEnumerable{Optimization.Interfaces.IExpression},System.Collections.Generic.IDictionary{System.String,System.Double})">
      <summary>
            Evaluates the specified expressions.
            </summary>
      <param name="expressions">The expressions.</param>
      <param name="variableValues">The variable values.</param>
      <returns />
    </member>
    <member name="M:Optimization.Operators.Times.ToString">
      <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
      <returns>
            A <see cref="T:System.String" /> that represents this instance.
            </returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object">Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="P:Optimization.Operators.Times.isLinear">
      <summary>
            Gets or sets a value indicating whether this instance is linear.
            </summary>
      <value>
        <c>true</c> if this instance is linear; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Optimization.Operators.Times.PreservesLinearity">
      <summary>
            Gets a value indicating whether this operator always preserves linearity when used with terms.
            </summary>
      <value>
        <c>true</c> if linearity is preserved otherwise, <c>false</c>.</value>
    </member>
    <member name="T:Optimization.ParameterCollection`1">
      <summary>
            A parameterCollection allows you to define parameters on Sets so that you can access parameter values with indices like in other modelling languages
            </summary>
      <typeparam name="T" />
    </member>
    <member name="M:Optimization.ParameterCollection`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Func{`0,System.Double},Optimization.Interfaces.ISetAccessor{`0,System.Object}[])">
      <summary>
            Initializes a new instance of the <see cref="T:Optimization.ParameterCollection`1" /> class.
            </summary>
      <param name="parameterValues">The parameter values.</param>
      <param name="valueExpression">The value expression.</param>
      <param name="sets">The sets.</param>
      <requires description="You need to provide a parameterValues collection.">parameterValues != null</requires>
    </member>
    <member name="P:Optimization.ParameterCollection`1.Item(System.Object[])">
      <summary>
            Gets the <see cref="T:System.Double" /> with the specified i.
            </summary>
      <value />
    </member>
    <member name="T:Optimization.SetAccessor`2">
      <summary>
            Defines a Set and an Accessor function
            </summary>
      <typeparam name="T">The type of the Set</typeparam>
      <typeparam name="S">The return type of the Accessor function</typeparam>
    </member>
    <member name="M:Optimization.SetAccessor`2.#ctor(System.Collections.Generic.IEnumerable{`1},System.Func{`0,`1})">
      <summary>
            Initializes a new instance of the <see cref="T:Optimization.SetAccessor`2" /> class.
            </summary>
      <param name="set">The set.</param>
      <param name="accessor">The accessor.</param>
    </member>
    <member name="P:Optimization.SetAccessor`2.Set">
      <summary>
            Gets the set.
            </summary>
      <value>The set.</value>
    </member>
    <member name="P:Optimization.SetAccessor`2.Accessor">
      <summary>
            Gets the accessor.
            </summary>
      <value>The accessor.</value>
    </member>
    <member name="T:Optimization.SumExpressionBuilder">
      <summary>
            This is a helper class to support efficiently building Expressions from a collection of Terms
            </summary>
    </member>
    <member name="M:Optimization.SumExpressionBuilder.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Optimization.SumExpressionBuilder" /> class.
            </summary>
    </member>
    <member name="M:Optimization.SumExpressionBuilder.Clear">
      <summary>
            Clears this instance.
            </summary>
    </member>
    <member name="M:Optimization.SumExpressionBuilder.Add(Optimization.Term)">
      <summary>
            Adds the specified term.
            </summary>
      <param name="term">The term.</param>
      <requires>(Object)term != null</requires>
    </member>
    <member name="M:Optimization.SumExpressionBuilder.ToExpression">
      <summary>
            Converts a list of terms to an expression by summing them up
            </summary>
      <returns>the resulting Expression</returns>
    </member>
    <member name="T:Optimization.Term">
      <summary>
            A term represents a variable and a coefficient which belongs to this variable (e.g. 2*x)
            </summary>
    </member>
    <member name="M:Optimization.Term.#ctor(Optimization.Interfaces.IVariable,System.Double)">
      <summary>
            Initializes a new instance of the <see cref="T:Optimization.Term" /> class.
            </summary>
      <param name="variable">The variable.</param>
      <param name="factor">The constant.</param>
      <exception cref="T:System.ArgumentNullException" />
    </member>
    <member name="M:Optimization.Term.op_Multiply(System.Double,Optimization.Term)">
      <summary>
            Implements the operator *.
            </summary>
      <param name="factor">The factor.</param>
      <param name="term">The term.</param>
      <returns>The result of the operator.</returns>
      <requires>!term.Equals(null)</requires>
      <ensures>(Object)Contract.Result&lt;Term&gt;() != null</ensures>
    </member>
    <member name="M:Optimization.Term.op_Multiply(Optimization.Term,System.Double)">
      <summary>
            Implements the operator *.
            </summary>
      <param name="term">The term.</param>
      <param name="factor">The factor.</param>
      <returns>The result of the operator.</returns>
      <requires>!object.Equals(term, null)</requires>
      <ensures>(Object)Contract.Result&lt;Term&gt;() != null</ensures>
    </member>
    <member name="M:Optimization.Term.op_Subtraction(System.Double,Optimization.Term)">
      <summary>
            Implements the operator -.
            </summary>
      <param name="constant">The constant.</param>
      <param name="term">The term.</param>
      <returns>The result of the operator.</returns>
      <requires>(Object)term != null</requires>
      <ensures>(Object)Contract.Result&lt;Expression&gt;() != null</ensures>
    </member>
    <member name="M:Optimization.Term.op_Subtraction(Optimization.Term,System.Double)">
      <summary>
            Implements the operator -.
            </summary>
      <param name="term">The term.</param>
      <param name="constant">The constant.</param>
      <returns>The result of the operator.</returns>
      <requires>(Object)term != null</requires>
      <ensures>(Object)Contract.Result&lt;Expression&gt;() != null</ensures>
    </member>
    <member name="M:Optimization.Term.op_Addition(System.Double,Optimization.Term)">
      <summary>
            Implements the operator +.
            </summary>
      <param name="constant">The constant.</param>
      <param name="term">The term.</param>
      <returns>The result of the operator.</returns>
      <requires>(Object)term != null</requires>
      <ensures>(Object)Contract.Result&lt;Expression&gt;() != null</ensures>
    </member>
    <member name="M:Optimization.Term.op_Addition(Optimization.Term,System.Double)">
      <summary>
            Implements the operator +.
            </summary>
      <param name="term">The term.</param>
      <param name="constant">The constant.</param>
      <returns>The result of the operator.</returns>
      <requires>(Object)term != null</requires>
      <ensures>(Object)Contract.Result&lt;Expression&gt;() != null</ensures>
    </member>
    <member name="M:Optimization.Term.op_Multiply(Optimization.Variable,Optimization.Term)">
      <summary>
            Implements the operator *.
            </summary>
      <param name="variable">The variable.</param>
      <param name="term">The term.</param>
      <returns>The result of the operator.</returns>
      <requires>!variable.Equals(null)</requires>
      <requires>(Object)term != null</requires>
      <ensures>(Object)Contract.Result&lt;Expression&gt;() != null</ensures>
    </member>
    <member name="M:Optimization.Term.op_Multiply(Optimization.Term,Optimization.Variable)">
      <summary>
            Implements the operator *.
            </summary>
      <param name="term">The term.</param>
      <param name="variable">The variable.</param>
      <returns>The result of the operator.</returns>
      <requires>!variable.Equals(null)</requires>
      <requires>(Object)term != null</requires>
      <ensures>(Object)Contract.Result&lt;Expression&gt;() != null</ensures>
    </member>
    <member name="M:Optimization.Term.op_Subtraction(Optimization.Variable,Optimization.Term)">
      <summary>
            Implements the operator -.
            </summary>
      <param name="variable">The variable.</param>
      <param name="term">The term.</param>
      <returns>The result of the operator.</returns>
      <requires>!variable.Equals(null)</requires>
      <requires>(Object)term != null</requires>
      <ensures>(Object)Contract.Result&lt;Expression&gt;() != null</ensures>
    </member>
    <member name="M:Optimization.Term.op_Subtraction(Optimization.Term,Optimization.Variable)">
      <summary>
            Implements the operator -.
            </summary>
      <param name="term">The term.</param>
      <param name="variable">The variable.</param>
      <returns>The result of the operator.</returns>
      <requires>!variable.Equals(null)</requires>
      <requires>(Object)term != null</requires>
      <ensures>(Object)Contract.Result&lt;Expression&gt;() != null</ensures>
    </member>
    <member name="M:Optimization.Term.op_Addition(Optimization.Variable,Optimization.Term)">
      <summary>
            Implements the operator +.
            </summary>
      <param name="variable">The variable.</param>
      <param name="term">The term.</param>
      <returns>The result of the operator.</returns>
      <requires>!variable.Equals(null)</requires>
      <requires>(Object)term != null</requires>
      <ensures>(Object)Contract.Result&lt;Expression&gt;() != null</ensures>
    </member>
    <member name="M:Optimization.Term.op_Addition(Optimization.Term,Optimization.Variable)">
      <summary>
            Implements the operator +.
            </summary>
      <param name="term">The term.</param>
      <param name="variable">The variable.</param>
      <returns>The result of the operator.</returns>
      <requires>!variable.Equals(null)</requires>
      <requires>(Object)term != null</requires>
      <ensures>(Object)Contract.Result&lt;Expression&gt;() != null</ensures>
    </member>
    <member name="M:Optimization.Term.op_Addition(Optimization.Term,Optimization.Term)">
      <summary>
            Implements the operator +.
            </summary>
      <param name="term">The first term.</param>
      <param name="term2">The second term.</param>
      <returns>The result of the operator.</returns>
      <requires>(Object)term != null</requires>
      <requires>(Object)term2 != null</requires>
      <ensures>(Object)Contract.Result&lt;Expression&gt;() != null</ensures>
    </member>
    <member name="M:Optimization.Term.op_Subtraction(Optimization.Term,Optimization.Term)">
      <summary>
            Implements the operator -.
            </summary>
      <param name="term">The term.</param>
      <param name="term2">The term2.</param>
      <returns>The result of the operator.</returns>
      <requires>(Object)term != null</requires>
      <requires>(Object)term2 != null</requires>
      <ensures>(Object)Contract.Result&lt;Expression&gt;() != null</ensures>
    </member>
    <member name="M:Optimization.Term.op_Multiply(Optimization.Term,Optimization.Term)">
      <summary>
            Implements the operator *.
            </summary>
      <param name="term">The term.</param>
      <param name="term2">The term2.</param>
      <returns>The result of the operator.</returns>
      <requires>(Object)term != null</requires>
      <requires>(Object)term2 != null</requires>
      <ensures>(Object)Contract.Result&lt;Expression&gt;() != null</ensures>
    </member>
    <member name="M:Optimization.Term.op_UnaryNegation(Optimization.Term)">
      <summary>
            Implements the operator -.
            </summary>
      <param name="term">The term.</param>
      <returns>The result of the operator.</returns>
      <requires>!object.Equals(term, null)</requires>
      <ensures>(Object)Contract.Result&lt;Term&gt;() != null</ensures>
    </member>
    <member name="M:Optimization.Term.ToString">
      <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
      <returns>
            A <see cref="T:System.String" /> that represents this instance.
            </returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object">Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="M:Optimization.Term.op_Implicit(Optimization.Variable)~Optimization.Term">
      <summary>
            Performs an implicit conversion from <see cref="T:Optimization.Variable" /> to <see cref="T:Optimization.Term" />.
            </summary>
      <param name="variable">The variable.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="P:Optimization.Term.Factor">
      <summary>
            Gets the factor.
            </summary>
    </member>
    <member name="P:Optimization.Term.Variable">
      <summary>
            Gets the variable.
            </summary>
    </member>
    <member name="P:Optimization.Term.isLinear">
      <summary>
            Gets or sets a value indicating whether this instance is linear.
            </summary>
      <value>
        <c>true</c> if this instance is linear; otherwise, <c>false</c>.</value>
    </member>
    <member name="P:Optimization.Term.Variables">
      <summary>
            Gets the variables.
            </summary>
    </member>
    <member name="P:Optimization.Term.Terms">
      <summary>
            Gets the terms.
            </summary>
    </member>
    <member name="T:Optimization.Variable">
      <summary>
            Represents a variable in an <see cref="T:Optimization.Interfaces.IModel" />.
            </summary>
      <author>lbeckmann</author>
    </member>
    <member name="M:Optimization.Variable.#ctor(System.String,System.Double,System.Double,Optimization.VariableType)">
      <summary>
            Initializes a new instance of the <see cref="T:Optimization.Variable" /> class.
            </summary>
      <param name="name">The name.</param>
      <param name="lowerbound">The lowerbound.</param>
      <param name="upperbound">The upperbound.</param>
      <param name="type">The type.</param>
    </member>
    <member name="M:Optimization.Variable.op_Subtraction(Optimization.Variable,Optimization.Variable)">
      <summary>
            Implements the operator -.
            </summary>
      <param name="variable">The first variable.</param>
      <param name="variable2">The second variable.</param>
      <returns>The result of the operator.</returns>
      <requires>!variable.Equals(null)</requires>
      <requires>variable2 != null</requires>
      <ensures>(Object)Contract.Result&lt;Expression&gt;() != null</ensures>
    </member>
    <member name="M:Optimization.Variable.op_Subtraction(Optimization.Variable,System.Double)">
      <summary>
            Implements the operator -.
            </summary>
      <param name="variable">The variable.</param>
      <param name="constant">The constant.</param>
      <returns>The result of the operator.</returns>
      <requires>!variable.Equals(null)</requires>
      <ensures>(Object)Contract.Result&lt;Expression&gt;() != null</ensures>
    </member>
    <member name="M:Optimization.Variable.op_Subtraction(System.Double,Optimization.Variable)">
      <summary>
            Implements the operator -.
            </summary>
      <param name="constant">The constant.</param>
      <param name="variable">The variable.</param>
      <returns>The result of the operator.</returns>
    </member>
    <member name="M:Optimization.Variable.op_Multiply(Optimization.Variable,System.Double)">
      <summary>
            Implements the operator *.
            </summary>
      <param name="variable">The variable.</param>
      <param name="constant">The constant.</param>
      <returns>The result of the operator.</returns>
      <requires>!variable.Equals(null)</requires>
      <ensures>(Object)Contract.Result&lt;Term&gt;() != null</ensures>
    </member>
    <member name="M:Optimization.Variable.op_Multiply(Optimization.Variable,Optimization.Variable)">
      <summary>
            Implements the operator *.
            </summary>
      <param name="variable1">The first variable.</param>
      <param name="variable2">The second variable.</param>
      <returns>The result of the operator.</returns>
      <requires>variable1 != null</requires>
      <requires>variable2 != null</requires>
      <ensures>(Object)Contract.Result&lt;Expression&gt;() != null</ensures>
    </member>
    <member name="M:Optimization.Variable.op_Multiply(System.Double,Optimization.Variable)">
      <summary>
            Implements the operator *.
            </summary>
      <param name="constant">The constant.</param>
      <param name="variable">The variable.</param>
      <returns>The result of the operator.</returns>
      <requires>!variable.Equals(null)</requires>
      <ensures>(Object)Contract.Result&lt;Term&gt;() != null</ensures>
    </member>
    <member name="M:Optimization.Variable.op_Addition(Optimization.Variable,Optimization.Variable)">
      <summary>
            Implements the operator +.
            </summary>
      <param name="variable">The first variable.</param>
      <param name="variable2">The second variable.</param>
      <returns>The result of the operator.</returns>
      <requires>!variable.Equals(null)</requires>
      <requires>variable2 != null</requires>
      <ensures>(Object)Contract.Result&lt;Expression&gt;() != null</ensures>
    </member>
    <member name="M:Optimization.Variable.op_Addition(Optimization.Variable,System.Double)">
      <summary>
            Implements the operator +.
            </summary>
      <param name="variable">The variable.</param>
      <param name="constant">The constant.</param>
      <returns>The result of the operator.</returns>
      <requires>!variable.Equals(null)</requires>
      <ensures>(Object)Contract.Result&lt;Expression&gt;() != null</ensures>
    </member>
    <member name="M:Optimization.Variable.op_Addition(System.Double,Optimization.Variable)">
      <summary>
            Implements the operator +.
            </summary>
      <param name="constant">The constant.</param>
      <param name="variable">The variable.</param>
      <returns>The result of the operator.</returns>
      <requires>!variable.Equals(null)</requires>
      <ensures>(Object)Contract.Result&lt;Expression&gt;() != null</ensures>
    </member>
    <member name="M:Optimization.Variable.ToString">
      <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
      <returns>
            A <see cref="T:System.String" /> that represents this instance.
            </returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object">Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="M:Optimization.Variable.Equals(Optimization.Variable)">
      <summary>
            Compares this instance to the specified other.
            </summary>
      <param name="other">The other.</param>
      <returns />
    </member>
    <member name="M:Optimization.Variable.Equals(System.Object)">
      <summary>
            Determines whether the specified <see cref="T:System.Object" /> is equal to this instance.
            </summary>
      <param name="obj">The <see cref="T:System.Object" /> to compare with this instance.</param>
      <returns>
        <c>true</c> if the specified <see cref="T:System.Object" /> is equal to this instance; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:Optimization.Variable.GetHashCode">
      <summary>
            Returns a hash code for this instance.
            </summary>
      <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table. 
            </returns>
    </member>
    <member name="M:Optimization.Variable.op_LessThanOrEqual(Optimization.Variable,Optimization.Term)">
      <summary>
            Implements the operator &lt;=.
            </summary>
      <param name="variable">The variable.</param>
      <param name="term">The term.</param>
      <returns>The result of the operator.</returns>
      <requires>!variable.Equals(null)</requires>
      <requires>(Object)term != null</requires>
      <ensures>Contract.Result&lt;Constraint&gt;() != null</ensures>
    </member>
    <member name="M:Optimization.Variable.op_GreaterThanOrEqual(Optimization.Variable,Optimization.Term)">
      <summary>
            Implements the operator &gt;=.
            </summary>
      <param name="variable">The variable.</param>
      <param name="term">The term.</param>
      <returns>The result of the operator.</returns>
      <requires>!variable.Equals(null)</requires>
      <requires>(Object)term != null</requires>
      <ensures>Contract.Result&lt;Constraint&gt;() != null</ensures>
    </member>
    <member name="M:Optimization.Variable.op_LessThanOrEqual(Optimization.Variable,System.Double)">
      <summary>
            Implements the operator &lt;=.
            </summary>
      <param name="variable">The variable.</param>
      <param name="constant">The constant.</param>
      <returns>The result of the operator.</returns>
      <requires>!variable.Equals(null)</requires>
      <ensures>Contract.Result&lt;Constraint&gt;() != null</ensures>
    </member>
    <member name="M:Optimization.Variable.op_GreaterThanOrEqual(Optimization.Variable,System.Double)">
      <summary>
            Implements the operator &gt;=.
            </summary>
      <param name="variable">The variable.</param>
      <param name="constant">The constant.</param>
      <returns>The result of the operator.</returns>
      <requires>!variable.Equals(null)</requires>
      <ensures>Contract.Result&lt;Constraint&gt;() != null</ensures>
    </member>
    <member name="M:Optimization.Variable.op_Equality(Optimization.Variable,System.Double)">
      <summary>
            Implements the operator ==.
            </summary>
      <param name="variable">The variable.</param>
      <param name="constant">The constant.</param>
      <returns>The result of the operator.</returns>
      <requires>!variable.Equals(null)</requires>
      <ensures>Contract.Result&lt;Constraint&gt;() != null</ensures>
    </member>
    <member name="M:Optimization.Variable.op_Equality(Optimization.Variable,Optimization.Variable)">
      <summary>
            Implements the operator ==.
            </summary>
      <param name="var1">The first variable.</param>
      <param name="var2">The second variable.</param>
      <returns>The result of the operator.</returns>
      <requires>var1 != null</requires>
    </member>
    <member name="M:Optimization.Variable.op_Equality(Optimization.Variable,Optimization.Term)">
      <summary>
            Implements the operator ==.
            </summary>
      <param name="variable">The variable.</param>
      <param name="term">The term.</param>
      <returns>The result of the operator.</returns>
      <requires>!variable.Equals(null)</requires>
      <requires>(Object)term != null</requires>
      <ensures>Contract.Result&lt;Constraint&gt;() != null</ensures>
    </member>
    <member name="M:Optimization.Variable.op_Inequality(Optimization.Variable,Optimization.Term)">
      <summary>
            Please use &lt;= and &gt;= to model !=
            </summary>
      <param name="variable">The variable.</param>
      <param name="term">The term.</param>
      <returns>The result of the operator.</returns>
    </member>
    <member name="M:Optimization.Variable.op_Inequality(Optimization.Variable,System.Double)">
      <summary>
            Please use &lt;= and &gt;= to model !=
            </summary>
      <param name="variable">The variable.</param>
      <param name="constant">The constant.</param>
      <returns>The result of the operator.</returns>
    </member>
    <member name="M:Optimization.Variable.op_UnaryNegation(Optimization.Variable)">
      <summary>
            Implements the operator -.
            </summary>
      <param name="variable">The variable.</param>
      <returns>
            A term with the factor of -1 and the variable given.
            </returns>
    </member>
    <member name="M:Optimization.Variable.op_Inequality(Optimization.Variable,Optimization.Variable)">
      <summary>
            Implements the operator !=.
            </summary>
      <param name="var1">The first variable.</param>
      <param name="var2">The second variable.</param>
      <returns>The result of the operator.</returns>
      <requires>var1 != null</requires>
    </member>
    <member name="P:Optimization.Variable.Name">
      <summary>
            Unique name of this variable.
            </summary>
      <value />
    </member>
    <member name="P:Optimization.Variable.LowerBound">
      <summary>
            Lower bound of this variable.
            </summary>
      <value />
    </member>
    <member name="P:Optimization.Variable.UpperBound">
      <summary>
            Upper bound of this variable.
            </summary>
      <value />
    </member>
    <member name="P:Optimization.Variable.Value">
      <summary>
            Gets or sets the value for this variable. This field can be used to assign solution values from a solver to the variables in the original model.
            </summary>
      <value>The value.</value>
    </member>
    <member name="P:Optimization.Variable.Type">
      <summary>
            Type of this variable.
            </summary>
      <value />
    </member>
    <member name="T:Optimization.VariableCollection">
      <summary>
            This is essentially a helper class that allows you to model your Variables more intuitively
            </summary>
    </member>
    <member name="M:Optimization.VariableCollection.#ctor(System.String,System.Double,System.Double,Optimization.VariableType,System.Collections.IEnumerable[])">
      <summary>
            Initializes a new instance of the <see cref="T:Optimization.VariableCollection" /> class.
            </summary>
      <param name="name">The name.</param>
      <param name="lowerBound">The lower bound.</param>
      <param name="upperBound">The upper bound.</param>
      <param name="type">The type.</param>
      <param name="sets">The sets.</param>
    </member>
    <member name="M:Optimization.VariableCollection.SetVariableValues(System.Collections.Generic.IDictionary{System.String,System.Double})">
      <summary>
             Sets the value property for each variable in this VariableCollection to the corresponding value in the parameter 'values'. The matching happens by string comparison of the name of the variable.
            </summary>
      <param name="values">The values for the variables (e.g. coming from a solution)</param>
    </member>
    <member name="M:Optimization.VariableCollection.CreateAllVariables">
      <summary>
            Creates all variables that can possibly be created based on the elements currently in the sets.
            </summary>
      <returns>All variables in this VariableCollection</returns>
    </member>
    <member name="P:Optimization.VariableCollection.IndexValidation">
      <summary>
             Changes the behavior of a VariableCollection. If set to true the VariableCollection will validate if an index belongs to the sets the VariableCollection is based on
            </summary>
    </member>
    <member name="P:Optimization.VariableCollection.Item(System.Object[])">
      <summary>
            Gets the <see cref="T:Optimization.Variable" /> with the specified index.
            </summary>
      <value />
    </member>
    <member name="T:Common.ExtensionMethods">
      <summary>
            Holds all Extension methods that are used throughout the framework
            </summary>
    </member>
    <member name="M:Common.ExtensionMethods.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
      <summary>
            Executes action on every element of source
            </summary>
      <typeparam name="T" />
      <param name="source">The source.</param>
      <param name="action">The action.</param>
      <requires>action != null</requires>
      <requires>source != null</requires>
    </member>
    <member name="M:Common.ExtensionMethods.MultiplyElements(System.Collections.Generic.IEnumerable{System.Double})">
      <summary>
            Multiplies the elements and returns the result.
            </summary>
      <param name="source">The source.</param>
      <returns />
      <requires>source != null</requires>
    </member>
    <member name="M:Common.ExtensionMethods.CartesianProduct``1(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{``0}})">
      <summary>
            Cartesians the product.
            </summary>
      <typeparam name="T" />
      <param name="sequences">The sequences.</param>
      <returns />
    </member>
    <member name="T:Common.ICloneable`1">
      <summary>
            Supports cloning, which creates a new instance of the same type with the same value as an existing instance.
            </summary>
      <typeparam name="T">The type of the original instance.</typeparam>
      <author>skramkowski</author>
    </member>
    <member name="M:Common.ICloneable`1.Clone">
      <summary>
            Creates a new object of type <typeparamref name="T" /> that is a copy of the current instance.
            </summary>
      <returns>A new object of type <typeparamref name="T" /> that is a copy of this instance.</returns>
      <remarks>Clone can be implemented either as a deep copy or a shallow copy. In a deep copy, all objects are duplicated; whereas, in a shallow copy, only the top-level objects are duplicated and the lower levels contain references.</remarks>
    </member>
    <member name="T:Common.ArrayEqualityComparer">
      <summary>
             This EqualityComparer can compare if an array of objects is equal to another array of objects by comparing the contained objects itself
            </summary>
    </member>
    <member name="M:Common.ArrayEqualityComparer.Equals(System.Object[],System.Object[])">
      <summary>
            Determines whether the specified objects are equal.
            </summary>
      <returns>
            true if the specified objects are equal; otherwise, false.
            </returns>
      <param name="x">The first object of type <paramref name="T" /> to compare.</param>
      <param name="y">The second object of type <paramref name="T" /> to compare.</param>
    </member>
    <member name="M:Common.ArrayEqualityComparer.GetHashCode(System.Object[])">
      <summary>
            Returns a hash code for the specified object.
            </summary>
      <returns>
            A hash code for the specified object.
            </returns>
      <param name="obj">The <see cref="T:System.Object" /> for which a hash code is to be returned.</param>
      <exception cref="T:System.ArgumentNullException">The type of <paramref name="obj" /> is a reference type and <paramref name="obj" /> is null.</exception>
    </member>
    <member name="T:Optimization.Interfaces.IConstraint">
      <summary>
            Represents a constraint in an <see cref="T:Optimization.Interfaces.IModel" />.
            </summary>
      <author>fseidel, skramkowski</author>
    </member>
    <member name="P:Optimization.Interfaces.IConstraint.Name">
      <summary>
            Unique name of this constraint.
            </summary>
    </member>
    <member name="P:Optimization.Interfaces.IConstraint.LowerBound">
      <summary>
            Lower bound (left hand side) of this constraint.
            </summary>
    </member>
    <member name="P:Optimization.Interfaces.IConstraint.UpperBound">
      <summary>
            Upper bound (right hand side) of this constraint.
            </summary>
    </member>
    <member name="P:Optimization.Interfaces.IConstraint.Expression">
      <summary>
            Expression of this constraint.
            </summary>
    </member>
    <member name="T:Optimization.Interfaces.IExpression">
      <summary>
            Describes the abilities of an Expression
            </summary>
      <author>lbeckmann, skramkowski</author>
    </member>
    <member name="M:Optimization.Interfaces.IExpression.Evaluate(System.Collections.Generic.IDictionary{System.String,System.Double})">
      <summary>
            Evaluates the expression using the specified variable values.
            </summary>
      <param name="variableValues">The variable values.</param>
      <returns />
      <requires>variableValues != null</requires>
    </member>
    <member name="P:Optimization.Interfaces.IExpression.isLinear">
      <summary>
            Gets or sets a value indicating whether this instance is linear.
            </summary>
      <value>
        <c>true</c> if this instance is linear; otherwise, <c>false</c>.</value>
    </member>
    <member name="P:Optimization.Interfaces.IExpression.Variables">
      <summary>
            Gets the variables.
            </summary>
      <value>The variables.</value>
    </member>
    <member name="P:Optimization.Interfaces.IExpression.Terms">
      <summary>
            Gets the terms.
            </summary>
      <value>The terms.</value>
    </member>
    <member name="P:Optimization.Interfaces.IExpression.Constant">
      <summary>
            Gets the constant.
            </summary>
      <value>The constant.</value>
    </member>
    <member name="T:Optimization.Interfaces.IExpressionVisitor`1">
      <summary>
            This is a helper class to create an expression for a solver visiting all nodes of an Optimization.Model.IExpression
            </summary>
    </member>
    <member name="M:Optimization.Interfaces.IExpressionVisitor`1.Visit(Optimization.Interfaces.IExpression)">
      <summary>
            Returns the corresponding expression of a solver
            </summary>
      <param name="exp">The Optimization.Model.IExpression</param>
      <returns>The expression for the solver</returns>
      <requires>exp!=null</requires>
    </member>
    <member name="T:Optimization.FileType">
      <summary>
            The filetype of a model file
            </summary>
    </member>
    <member name="F:Optimization.FileType.MPS">
      <summary>
            MPS
            </summary>
    </member>
    <member name="F:Optimization.FileType.OSiL">
      <summary>
            OSiL
            </summary>
    </member>
    <member name="F:Optimization.FileType.LP">
      <summary>
            LP
            </summary>
    </member>
    <member name="T:Optimization.Interfaces.IOperatorExpression">
      <summary>
            Any operation (Plus, Times, etc.) that wants to be exposed as an expression needs to implement this interface
            </summary>
    </member>
    <member name="P:Optimization.Interfaces.IOperatorExpression.Expressions">
      <summary>
            Gets the expressions.
            </summary>
    </member>
    <member name="T:Optimization.Interfaces.IAbs">
      <summary>
            Describes the interface for the Abs operation
            </summary>
    </member>
    <member name="T:Optimization.Interfaces.ICanTransform`2">
      <summary>
             A class which implements this interface can convert objects of type M1 to objects of type M2
            </summary>
      <typeparam name="M1">Type to convert from</typeparam>
      <typeparam name="M2">Type to convert to</typeparam>
    </member>
    <member name="T:Optimization.Interfaces.ICeil">
      <summary>
            Describes the interface for the Ceil operation
            </summary>
    </member>
    <member name="T:Optimization.Interfaces.IConstantExpression">
      <summary>
            The interface any expression that wants to expose a constant element needs to implement
            </summary>
    </member>
    <member name="P:Optimization.Interfaces.IConstantExpression.Constant">
      <summary>
            Gets the constant.
            </summary>
    </member>
    <member name="T:Optimization.Interfaces.IFloor">
      <summary>
            Describes the interface for the Floor operation
            </summary>
    </member>
    <member name="T:Optimization.Interfaces.ILinearConstraint">
      <summary>
            Represents a constraint in an <see cref="T:Optimization.Interfaces.ILinearModel" />.
            </summary>
      <author>skramkowski</author>
    </member>
    <member name="M:Optimization.Interfaces.ILinearConstraint.ContentEquals(Optimization.Interfaces.ILinearConstraint)">
      <summary>
            Compares the lower bound, upper bound, coefficients etc., but not the name.
            </summary>
      <param name="other">The <see cref="T:Optimization.Interfaces.ILinearConstraint" /> to compare to.</param>
      <returns />
    </member>
    <member name="P:Optimization.Interfaces.ILinearConstraint.Coefficients">
      <summary>
            Non-zero coefficients in this constraint.
            </summary>
    </member>
    <member name="P:Optimization.Interfaces.ILinearConstraint.CoefficientsCount">
      <summary>
            Count of non-zero coefficients in this constraint.
            </summary>
    </member>
    <member name="P:Optimization.Interfaces.ILinearConstraint.Item(System.String)">
      <summary>
            Gets or sets the coefficient of the variable named <paramref name="name" /> in this constraint.
            </summary>
      <param name="name">Name of the variable.</param>
      <returns />
    </member>
    <member name="T:Optimization.Interfaces.IModel">
      <summary>
            Represents a mathematical programming problem.
            Supports mixed integer non-linear programming problems with multiple objectives and stochastic.
            </summary>
      <author>fseidel, skramkowski, lbeckmann</author>
    </member>
    <member name="M:Optimization.Interfaces.IModel.AddVariable(Optimization.Interfaces.IVariable)">
      <summary>
            Adds <paramref name="variable" /> to this model instance if it is consistent.
            </summary>
      <param name="variable">Variable to add.</param>
      <requires>variable != null</requires>
    </member>
    <member name="M:Optimization.Interfaces.IModel.AddVariable(System.String,System.Double,System.Double,Optimization.VariableType)">
      <summary>
            Adds a new variable to this model instance if it is consistent.
            </summary>
      <param name="name">Unique name of the new variable.</param>
      <param name="lowerBound">Lower bound of the new variable.</param>
      <param name="upperBound">Upper bound of the new variable.</param>
      <param name="type">Type of the new variable.</param>
    </member>
    <member name="M:Optimization.Interfaces.IModel.AddSOS1(System.Collections.Generic.IDictionary{Optimization.Interfaces.IVariable,System.Double})">
      <summary>
            Adds an SOS1 constraint
            </summary>
      <param name="variables">The variables.</param>
    </member>
    <member name="M:Optimization.Interfaces.IModel.AddSOS2(System.Collections.Generic.IDictionary{Optimization.Interfaces.IVariable,System.Double})">
      <summary>
            Adds an SOS2 constraint
            </summary>
      <param name="variables">The variables.</param>
    </member>
    <member name="M:Optimization.Interfaces.IModel.AddSOS3(System.Collections.Generic.IDictionary{Optimization.Interfaces.IVariable,System.Double})">
      <summary>
            Adds an SOS3 constraint
            </summary>
      <param name="variables">The variables.</param>
    </member>
    <member name="M:Optimization.Interfaces.IModel.AddSOS(System.Collections.Generic.IDictionary{Optimization.Interfaces.IVariable,System.Double},Optimization.SOSType)">
      <summary>
            Adds an SOS Constraint of the given SOSType
            </summary>
      <param name="variables">The variables.</param>
      <param name="type">The type.</param>
    </member>
    <member name="M:Optimization.Interfaces.IModel.AddConstraint(Optimization.Interfaces.IConstraint,System.String)">
      <summary>
            Adds <paramref name="constraint" /> to this model instance if it is consistent. If you choose to provide a name, the name of the constraint will be overridden.
            You need to make sure that the name of the constraint is unique.
            </summary>
      <param name="constraint">Constraint to add.</param>
      <param name="name">The name for the constraint</param>
      <requires>constraint != null</requires>
    </member>
    <member name="M:Optimization.Interfaces.IModel.AddConstraint(System.String,System.Double,System.Double,Optimization.Interfaces.IExpression)">
      <summary>
            Adds a new constraint to this model instance if it is consistent.
            </summary>
      <param name="name">Unique name of the new constraint.</param>
      <param name="lowerBound">Lower bound (left hand side) of the new constraint.</param>
      <param name="upperBound">Upper bound (right hand side) of the new constraint.</param>
      <param name="expression">Expression of the new constraint.</param>
    </member>
    <member name="M:Optimization.Interfaces.IModel.AddObjective(Optimization.Interfaces.IObjective)">
      <summary>
            Adds <paramref name="objective" /> to this model instance if it is consistent.
            </summary>
      <param name="objective">Objective to add.</param>
      <requires>objective != null</requires>
    </member>
    <member name="M:Optimization.Interfaces.IModel.AddObjective(Optimization.Interfaces.IExpression,System.String,Optimization.ObjectiveSense)">
      <summary>
            Adds a new objective to this model instance if it is consistent.
            </summary>
      <param name="expression">Expression of the new objective.</param>
      <param name="name">Unique name of the new objective.</param>
      <param name="sense">Sense of the new objective.</param>
    </member>
    <member name="M:Optimization.Interfaces.IModel.AddVariables(System.Collections.Generic.IEnumerable{Optimization.Interfaces.IVariable})">
      <summary>
            Adds a set of variables to this model instance if it is consistent.
            </summary>
      <param name="variables">Set of variables to add.</param>
      <requires>variables != null</requires>
    </member>
    <member name="M:Optimization.Interfaces.IModel.AddConstraints(System.Collections.Generic.IEnumerable{Optimization.Interfaces.IConstraint})">
      <summary>
            Adds a set of constraint to this model instance if it is consistent.
            </summary>
      <param name="constraints">Set of constraints to add.</param>
      <requires>constraints != null</requires>
    </member>
    <member name="M:Optimization.Interfaces.IModel.AddAlternativeConstraintGroups(System.Collections.Generic.IEnumerable{Optimization.Interfaces.IConstraint},System.Collections.Generic.IEnumerable{Optimization.Interfaces.IConstraint},System.Double)">
      <summary>
            OR connects the constraints from group1 with the constraints from group2
            </summary>
      <param name="group1">The first constraint group.</param>
      <param name="group2">The second constraint group.</param>
      <param name="bigM">A number as small as possible, so that no constraint is limited by this number</param>
    </member>
    <member name="M:Optimization.Interfaces.IModel.AddAlternativeConstraints(System.Collections.Generic.IEnumerable{Optimization.Interfaces.IConstraint},System.Double)">
      <summary>
            Adds the constraints to the model. The contained constraints will be OR connected -&gt; at least one constraint must be true
            </summary>
      <param name="constraints">The constraints.</param>
      <param name="bigM">A number as small as possible, so that no constraint is limited by this number</param>
    </member>
    <member name="M:Optimization.Interfaces.IModel.AddObjectives(System.Collections.Generic.IEnumerable{Optimization.Interfaces.IObjective})">
      <summary>
            Adds a set of objectives to this model instance if it is consistent.
            </summary>
      <param name="objectives">Set of objectives to add.</param>
      <requires>objectives != null</requires>
    </member>
    <member name="M:Optimization.Interfaces.IModel.Clear">
      <summary>
            Removes all variables, constraints, objectives and scenarios from this model instance.
            </summary>
    </member>
    <member name="M:Optimization.Interfaces.IModel.ContainsVariable(System.String)">
      <summary>
            Contains this model instance a variable named <paramref name="name" />?
            </summary>
      <param name="name">Name of the variable to search for.</param>
      <returns />
      <requires>name != null</requires>
    </member>
    <member name="M:Optimization.Interfaces.IModel.ContainsConstraint(System.String)">
      <summary>
            Contains this model instance a constraint named <paramref name="name" />?
            </summary>
      <param name="name">Name of the constraint to search for.</param>
      <returns />
      <requires>name != null</requires>
    </member>
    <member name="M:Optimization.Interfaces.IModel.ContainsObjective(System.String)">
      <summary>
            Contains this model instance an objective named <paramref name="name" />?
            </summary>
      <param name="name">Name of the objective to search for.</param>
      <returns />
      <requires>name != null</requires>
    </member>
    <member name="M:Optimization.Interfaces.IModel.GetVariable(System.String)">
      <summary>
            Returns the variable named <paramref name="name" />, or <c>null</c> if this model instance contains no such variable.
            </summary>
      <param name="name">Name of the variable to search for.</param>
      <returns />
      <requires>name != null</requires>
    </member>
    <member name="M:Optimization.Interfaces.IModel.GetConstraint(System.String)">
      <summary>
            Returns the constraint named <paramref name="name" />, or <c>null</c> if this model instance contains no such constraint.
            </summary>
      <param name="name">Name of the constraint to search for.</param>
      <returns />
      <requires>name != null</requires>
    </member>
    <member name="M:Optimization.Interfaces.IModel.GetObjective(System.String)">
      <summary>
            Returns the objective named <paramref name="name" />, or <c>null</c> if this model instance contains no such objective.
            </summary>
      <param name="name">Name of the objective to serach for.</param>
      <returns />
      <requires>name != null</requires>
    </member>
    <member name="M:Optimization.Interfaces.IModel.RemoveVariable(System.String)">
      <summary>
            Removes the variable named <paramref name="name" /> from this model instance, or does nothing if this model instance contains no such variable.
            </summary>
      <param name="name">Name of the variable to remove.</param>
      <requires>name != null</requires>
    </member>
    <member name="M:Optimization.Interfaces.IModel.RemoveConstraint(System.String)">
      <summary>
            Removes the constraint named <paramref name="name" /> from this model instance, or does nothing if this model instance contains no such constraint.
            </summary>
      <param name="name">Name of the constraint to remove.</param>
      <requires>name != null</requires>
    </member>
    <member name="M:Optimization.Interfaces.IModel.RemoveObjective(System.String)">
      <summary>
            Removes the objective named <paramref name="name" /> from this model instance, or does nothing if this model instance contains no such objective.
            </summary>
      <param name="name">Name of the objective to remove.</param>
      <requires>name != null</requires>
    </member>
    <member name="M:Optimization.Interfaces.IModel.RemoveVariables(System.Collections.Generic.IEnumerable{System.String})">
      <summary>
            Removes a set of variables from this model instance.
            </summary>
      <param name="names">Names of the variables to remove.</param>
      <requires>names != null</requires>
    </member>
    <member name="M:Optimization.Interfaces.IModel.RemoveConstraints(System.Collections.Generic.IEnumerable{System.String})">
      <summary>
            Removes a set of constraints from this model instance.
            </summary>
      <param name="names">Names of the constraints to remove.</param>
      <requires>names != null</requires>
    </member>
    <member name="M:Optimization.Interfaces.IModel.RemoveObjectives(System.Collections.Generic.IEnumerable{System.String})">
      <summary>
            Removes a set of objectives from this model instance.
            </summary>
      <param name="names">Names of the objectives to remove.</param>
      <requires>names != null</requires>
    </member>
    <member name="M:Optimization.Interfaces.IModel.Load(System.IO.Stream)">
      <summary>
            Loads the specified file with the specified filetype.
            </summary>
      <param name="filestream">The filestream.</param>
      <requires>filestream!=null</requires>
    </member>
    <member name="M:Optimization.Interfaces.IModel.Write(System.IO.Stream,Optimization.FileType)">
      <summary>
            Writes the model to the specified filestream.
            </summary>
      <param name="filestream">The filestream.</param>
      <param name="fileType">Type of the file.</param>
      <requires>filestream != null</requires>
    </member>
    <member name="P:Optimization.Interfaces.IModel.Name">
      <summary>
            Name of this model instance.
            </summary>
    </member>
    <member name="P:Optimization.Interfaces.IModel.ModelBehavior">
      <summary>
            Gets or sets the behavior of the model. Available options are "Automatic" and "Manual"
            In automatic mode, the model takes care of adding and removing variables when constraints and objectives get added. In manual mode you need to take care of this yourself.
            </summary>
      <value>The model behavior.</value>
    </member>
    <member name="P:Optimization.Interfaces.IModel.Variables">
      <summary>
            Variables in this model instance.
            </summary>
    </member>
    <member name="P:Optimization.Interfaces.IModel.SOS1Sets">
      <summary>
            Sets of SOS1 variables in this model instance.
            </summary>
    </member>
    <member name="P:Optimization.Interfaces.IModel.SOS2Sets">
      <summary>
            Sets of SOS2 variables in this model instance.
            </summary>
    </member>
    <member name="P:Optimization.Interfaces.IModel.SOS3Sets">
      <summary>
            Sets of SOS3 variables in this model instance.
            </summary>
    </member>
    <member name="P:Optimization.Interfaces.IModel.Constraints">
      <summary>
            Constraints in this model instance.
            </summary>
    </member>
    <member name="P:Optimization.Interfaces.IModel.Objectives">
      <summary>
            Objectives in this model instance.
            </summary>
    </member>
    <member name="P:Optimization.Interfaces.IModel.VariablesCount">
      <summary>
            Count of variables in this model instance.
            </summary>
    </member>
    <member name="P:Optimization.Interfaces.IModel.ConstraintsCount">
      <summary>
            Count of constraints in this model instance.
            </summary>
    </member>
    <member name="P:Optimization.Interfaces.IModel.ObjectivesCount">
      <summary>
            Count of objectives in this model instance.
            </summary>
    </member>
    <member name="P:Optimization.Interfaces.IModel.AreAllVariablesBinary">
      <summary>
            Are all variables in this model instance of type integer and their lower bound equal to zero and their upper bound equal to 1?
            </summary>
    </member>
    <member name="P:Optimization.Interfaces.IModel.AreAllVariablesInteger">
      <summary>
            Are all variables in this model instance of type integer?
            </summary>
    </member>
    <member name="P:Optimization.Interfaces.IModel.AreAllVariablesContinuous">
      <summary>
            Are variables in this model instance of type continuous?
            </summary>
    </member>
    <member name="P:Optimization.Interfaces.IModel.AreAllConstraintsLinear">
      <summary>
            Have all constraints in this model instance linear expressions?
            </summary>
    </member>
    <member name="P:Optimization.Interfaces.IModel.AreAllObjectivesLinear">
      <summary>
            Have all objectives in this model instance linear expressions?
            </summary>
    </member>
    <member name="T:Optimization.Interfaces.ILinearModel">
      <summary>
            Represents a mathematical programming problem, where all constraints and objectives have linear expressions.
            Also called mixed integer linear programming problem with multiple objectives but no stochastic.
            </summary>
      <author>skramkowski</author>
    </member>
    <member name="M:Optimization.Interfaces.ILinearModel.AddVariable(Optimization.Interfaces.ILinearVariable)">
      <summary>
            Adds <paramref name="variable" /> to this model instance if it is consistent.
            </summary>
      <param name="variable">Variable to add.</param>
    </member>
    <member name="M:Optimization.Interfaces.ILinearModel.AddVariable(System.String,System.Double,System.Double,Optimization.VariableType,System.Collections.Generic.IDictionary{System.String,System.Double},System.Collections.Generic.IDictionary{System.String,System.Double})">
      <summary>
            Adds a new variable to this model instance if it is consistent.
            </summary>
      <param name="name">Unique name of the new variable.</param>
      <param name="lowerBound">Lower bound of the new variable.</param>
      <param name="upperBound">Upper bound of the new variable.</param>
      <param name="type">Type of the new variable.</param>
      <param name="objectiveCoefficients">Non-zero objective coefficients of the new variable.</param>
      <param name="constraintCoefficients">Non-zero constraint coefficients of the new variable.</param>
    </member>
    <member name="M:Optimization.Interfaces.ILinearModel.AddConstraint(Optimization.Interfaces.ILinearConstraint)">
      <summary>
            Adds <paramref name="constraint" /> to this model instance if it is consistent.
            </summary>
      <param name="constraint">Constraint to add.</param>
    </member>
    <member name="M:Optimization.Interfaces.ILinearModel.AddConstraint(System.String,System.Double,System.Double,System.Collections.Generic.IDictionary{System.String,System.Double})">
      <summary>
            Adds a new constraint to this model instance if it is consistent.
            </summary>
      <param name="name">Unique name of the new constraint.</param>
      <param name="lowerBound">Lower bound (left hand side) of the new constraint.</param>
      <param name="upperBound">Upper bound (right hand side) of the new constraint.</param>
      <param name="coefficients">Non-zero coefficients of the new constraint.</param>
    </member>
    <member name="M:Optimization.Interfaces.ILinearModel.AddObjective(Optimization.Interfaces.ILinearObjective)">
      <summary>
            Adds <paramref name="objective" /> to this model instance if it is consistent.
            </summary>
      <param name="objective">Objective to add.</param>
    </member>
    <member name="M:Optimization.Interfaces.ILinearModel.AddObjective(System.String,Optimization.ObjectiveSense,System.Collections.Generic.IDictionary{System.String,System.Double})">
      <summary>
            Adds a new objective to this model instance if it is consistent.
            </summary>
      <param name="name">Unique name of the new objective.</param>
      <param name="sense">Sense of the new objective.</param>
      <param name="coefficients">Non-zero coefficients of the new objective.</param>
    </member>
    <member name="M:Optimization.Interfaces.ILinearModel.AddVariables(System.Collections.Generic.ISet{Optimization.Interfaces.ILinearVariable})">
      <summary>
            Adds a set of variables to this model instance if it is consistent.
            </summary>
      <param name="variables">Set of variables to add.</param>
    </member>
    <member name="M:Optimization.Interfaces.ILinearModel.AddConstraints(System.Collections.Generic.ISet{Optimization.Interfaces.ILinearConstraint})">
      <summary>
            Adds a set of constraint to this model instance if it is consistent.
            </summary>
      <param name="constraints">Set of constraints to add.</param>
    </member>
    <member name="M:Optimization.Interfaces.ILinearModel.AddObjectives(System.Collections.Generic.ISet{Optimization.Interfaces.ILinearObjective})">
      <summary>
            Adds a set of objectives to this model instance if it is consistent.
            </summary>
      <param name="objectives">Set of objectives to add.</param>
    </member>
    <member name="M:Optimization.Interfaces.ILinearModel.GetVariable(System.String)">
      <summary>
            Returns the variable named <paramref name="name" />, or <c>null</c> if this model instance contains no such variable.
            </summary>
      <param name="name">Name of the variable to search for.</param>
      <returns />
    </member>
    <member name="M:Optimization.Interfaces.ILinearModel.GetConstraint(System.String)">
      <summary>
            Returns the constraint named <paramref name="name" />, or <c>null</c> if this model instance contains no such constraint.
            </summary>
      <param name="name">Name of the constraint to search for.</param>
      <returns />
    </member>
    <member name="M:Optimization.Interfaces.ILinearModel.GetObjective(System.String)">
      <summary>
            Returns the objective named <paramref name="name" />, or <c>null</c> if this model instance contains no such objective.
            </summary>
      <param name="name">Name of the objective to serach for.</param>
      <returns />
    </member>
    <member name="P:Optimization.Interfaces.ILinearModel.Variables">
      <summary>
            Variables in this model instance.
            </summary>
    </member>
    <member name="P:Optimization.Interfaces.ILinearModel.Constraints">
      <summary>
            Constraints in this model instance.
            </summary>
    </member>
    <member name="P:Optimization.Interfaces.ILinearModel.Objectives">
      <summary>
            Objectives in this model instance.
            </summary>
    </member>
    <member name="P:Optimization.Interfaces.ILinearModel.ConstraintCoefficientsCount">
      <summary>
            Count of non-zero constraint coefficients in this model instance.
            </summary>
    </member>
    <member name="P:Optimization.Interfaces.ILinearModel.ObjectiveCoefficientsCount">
      <summary>
            Count of non-zero objective coefficients in this model instance.
            </summary>
    </member>
    <member name="T:Optimization.Interfaces.IObjective">
      <summary>
            Represents an objective in an <see cref="T:Optimization.Interfaces.IModel" />.
            </summary>
      <author>fseidel, skramkowski</author>
    </member>
    <member name="P:Optimization.Interfaces.IObjective.Name">
      <summary>
            Unique name of this objective.
            </summary>
    </member>
    <member name="P:Optimization.Interfaces.IObjective.Sense">
      <summary>
            Sense of this objective.
            </summary>
    </member>
    <member name="P:Optimization.Interfaces.IObjective.Expression">
      <summary>
            Expression of this objective.
            </summary>
    </member>
    <member name="T:Optimization.Interfaces.ILinearObjective">
      <summary>
            Represents an objective in an <see cref="T:Optimization.Interfaces.ILinearModel" />.
            </summary>
      <author>skramkowski</author>
    </member>
    <member name="M:Optimization.Interfaces.ILinearObjective.ContentEquals(Optimization.Interfaces.ILinearObjective)">
      <summary>
            Compares the lower bound, upper bound, coefficients etc., but not the name.
            </summary>
      <param name="other">The <see cref="T:Optimization.Interfaces.ILinearObjective" /> to compare to.</param>
      <returns />
    </member>
    <member name="P:Optimization.Interfaces.ILinearObjective.Coefficients">
      <summary>
            Non-zero coefficients in this objective.
            </summary>
    </member>
    <member name="P:Optimization.Interfaces.ILinearObjective.CoefficientsCount">
      <summary>
            Count of non-zero coefficients in this objective.
            </summary>
    </member>
    <member name="P:Optimization.Interfaces.ILinearObjective.Item(System.String)">
      <summary>
            Gets or sets the coefficient of the variable named <paramref name="name" /> in this objective.
            </summary>
      <param name="name">Name of the variable.</param>
      <returns />
    </member>
    <member name="T:Optimization.Interfaces.IVariable">
      <summary>
            Represents a variable in an <see cref="T:Optimization.Interfaces.IModel" />.
            </summary>
      <author>fseidel, skramkowski</author>
    </member>
    <member name="P:Optimization.Interfaces.IVariable.Name">
      <summary>
            Unique name of this variable.
            </summary>
    </member>
    <member name="P:Optimization.Interfaces.IVariable.LowerBound">
      <summary>
            Lower bound of this variable.
            </summary>
    </member>
    <member name="P:Optimization.Interfaces.IVariable.UpperBound">
      <summary>
            Upper bound of this variable.
            </summary>
    </member>
    <member name="P:Optimization.Interfaces.IVariable.Value">
      <summary>
            Gets or sets the value for this variable. This field can be used to assign solution values from a solver to the variables in the original model.
            </summary>
      <value>The value.</value>
    </member>
    <member name="P:Optimization.Interfaces.IVariable.Type">
      <summary>
            Type of this variable.
            </summary>
    </member>
    <member name="T:Optimization.Interfaces.ILinearVariable">
      <summary>
            Represents a variable in an <see cref="T:Optimization.Interfaces.ILinearModel" />.
            </summary>
      <author>skramkowski</author>
    </member>
    <member name="M:Optimization.Interfaces.ILinearVariable.GetObjectiveCoefficient(System.String)">
      <summary>
            Returns the coefficient of this variable in the objective named <paramref name="name" />.
            </summary>
      <param name="name">Name of the objective.</param>
      <returns />
    </member>
    <member name="M:Optimization.Interfaces.ILinearVariable.SetObjectiveCoefficient(System.String,System.Double)">
      <summary>
            Sets the coefficient of this variable in the objective named <paramref name="name" />.
            </summary>
      <param name="name">Name of the objective.</param>
      <param name="coefficient">Value to set.</param>
    </member>
    <member name="M:Optimization.Interfaces.ILinearVariable.GetConstraintCoefficient(System.String)">
      <summary>
            Returns the coefficient of this variable in the constraint named <paramref name="name" />.
            </summary>
      <param name="name">Name of the constraint.</param>
      <returns />
    </member>
    <member name="M:Optimization.Interfaces.ILinearVariable.SetConstraintCoefficient(System.String,System.Double)">
      <summary>
            Sets the coefficient of this variable in the constraint named <paramref name="name" />.
            </summary>
      <param name="name">Name of the constraint.</param>
      <param name="coefficient">Value to set.</param>
    </member>
    <member name="M:Optimization.Interfaces.ILinearVariable.ContentEquals(Optimization.Interfaces.ILinearVariable)">
      <summary>
            Compares the lower bound, upper bound, type etc., but not the name.
            </summary>
      <param name="other">The <see cref="T:Optimization.Interfaces.ILinearVariable" /> to compare to.</param>
      <returns />
    </member>
    <member name="P:Optimization.Interfaces.ILinearVariable.ObjectiveCoefficients">
      <summary>
            Non-zero objective coefficients of this variable.
            </summary>
    </member>
    <member name="P:Optimization.Interfaces.ILinearVariable.ConstraintCoefficients">
      <summary>
            Non-zero constraint coefficients of this variable.
            </summary>
    </member>
    <member name="P:Optimization.Interfaces.ILinearVariable.ObjectiveCoefficientsCount">
      <summary>
            Count of non-zero objective coefficients of this variable.
            </summary>
    </member>
    <member name="P:Optimization.Interfaces.ILinearVariable.ConstraintCoefficientsCount">
      <summary>
            Count of non-zero constraint coefficients of this variable.
            </summary>
    </member>
    <member name="T:Optimization.Interfaces.IMax">
      <summary>
            Describes the interface for the max operation
            </summary>
    </member>
    <member name="T:Optimization.Interfaces.IMin">
      <summary>
            Describes the interface for the min operation
            </summary>
    </member>
    <member name="M:Optimization.Interfaces.IOperator.Evaluate(System.Collections.Generic.IEnumerable{Optimization.Interfaces.IExpression},System.Collections.Generic.IDictionary{System.String,System.Double})">
      <summary>
            Evaluates the specified expressions using the specified variableValues
            </summary>
      <param name="expressions">The expressions.</param>
      <param name="variableValues">The variable values.</param>
      <returns />
    </member>
    <member name="P:Optimization.Interfaces.IOperator.PreservesLinearity">
      <summary>
            Gets a value indicating whether this operator always preserves linearity when used with terms.
            </summary>
      <value>
        <c>true</c> if linearity is preserved otherwise, <c>false</c>.</value>
    </member>
    <member name="T:Optimization.Solver.ICanSolveP2P`1">
      <summary>
            Exposes the solve method that is used in a P2P scenario
            </summary>
      <typeparam name="M" />
    </member>
    <member name="M:Optimization.Solver.ICanSolveP2P`1.Solve(`0,System.Collections.Generic.IDictionary{System.String,System.Double})">
      <summary>
            Solves the given <paramref name="model" />.
            Optimizes if <paramref name="model" /> contains at least one objective.
            </summary>
      <param name="model">The model to solve.</param>
      <param name="variableValues">Initial values for all or a subset of variables in <paramref name="model" />.</param>
      <returns />
      <exception cref="T:System.NotSupportedException">If this solver instance not supports solving.</exception>
      <exception cref="T:System.InvalidOperationException">If this solver instance is busy.</exception>
      <exception cref="T:System.ArgumentException">If this solver instance cannot handle the kind of <paramref name="model" />.</exception>
    </member>
    <member name="T:Optimization.Solver.ICanHandleSolverEventOfType`1">
      <summary>
            Indicates that the implementing class can handle a certain SolverEvent
            </summary>
      <typeparam name="T" />
    </member>
    <member name="M:Optimization.Solver.ICanHandleSolverEventOfType`1.HandleEvent(`0)">
      <summary>
            Handles the event. This can for example be an event that is fired whenever a NewIncombent was found during the solution process.
            </summary>
      <param name="solverEvent">The solver event.</param>
    </member>
    <member name="T:Optimization.Interfaces.IP2PSolver">
      <summary>
            Describes the abilities of a P2P solver
            </summary>
    </member>
    <member name="M:Optimization.Interfaces.IP2PSolver.AskForNodes(System.Guid)">
      <summary>
            A solver that has no more work and needs a node to continue calls this method to find all busy solvers that have nodes available
            </summary>
    </member>
    <member name="M:Optimization.Interfaces.IP2PSolver.Join(System.Guid)">
      <summary>
            A solver joins the mesh and communicates its id
            </summary>
      <param name="id">The id.</param>
    </member>
    <member name="M:Optimization.Interfaces.IP2PSolver.Leave(System.Guid)">
      <summary>
            A solver leaves the mesh and communicates its id
            </summary>
      <param name="id">The id.</param>
    </member>
    <member name="M:Optimization.Interfaces.IP2PSolver.RequestNode(System.Guid)">
      <summary>
            A solver that has no more work and needs a node to continue calls this method on one specific solver
            </summary>
    </member>
    <member name="M:Optimization.Interfaces.IP2PSolver.NodeReply(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{Optimization.Interfaces.IConstraint}})">
      <summary>
            This list of IConstraints will be used to restrict the solver to this one node and its subnodes
            </summary>
      <param name="nodes">The node.</param>
    </member>
    <member name="M:Optimization.Interfaces.IP2PSolver.JoinReply(System.Guid)">
      <summary>
            All solvers communicate thir ids to a joining solver.
            </summary>
      <param name="id">The id.</param>
    </member>
    <member name="M:Optimization.Interfaces.IP2PSolver.AskForNodesReplyPositive(System.Guid)">
      <summary>
            A solver calls this method if he has nodes available in its nodelist
            </summary>
    </member>
    <member name="M:Optimization.Interfaces.IP2PSolver.AskForNodesReplyNegative">
      <summary>
            A solver calls this method if he has no nodes available in its nodelist
            </summary>
    </member>
    <member name="M:Optimization.Interfaces.IP2PSolver.InitializeMesh">
      <summary>
            Initializes the mesh.
            </summary>
    </member>
    <member name="T:Optimization.Interfaces.IP2PSolverChannel">
      <summary>
            A WCF channel for IP2PSolver
            </summary>
    </member>
    <member name="T:Optimization.Interfaces.IPlus">
      <summary>
            Describes the interface for the plus operation
            </summary>
    </member>
    <member name="T:Optimization.Interfaces.ISetAccessor`2">
      <summary>
            Defines a Set and an Accessor function
            </summary>
      <typeparam name="T">The type of the Set</typeparam>
      <typeparam name="S">The return type of the Accessor function</typeparam>
    </member>
    <member name="P:Optimization.Interfaces.ISetAccessor`2.Set">
      <summary>
            Gets the set.
            </summary>
      <value>The set.</value>
    </member>
    <member name="P:Optimization.Interfaces.ISetAccessor`2.Accessor">
      <summary>
            Gets the accessor.
            </summary>
      <value>The accessor.</value>
    </member>
    <member name="T:Optimization.Interfaces.ISolution">
      <summary>
            The solution to an <see cref="T:Optimization.Interfaces.IModel" /> needs to implement this interface
            </summary>
    </member>
    <member name="M:Optimization.Interfaces.ISolution.CompareTo(Optimization.Solution)">
      <summary>
            Compares the objective values of this solution instance to <paramref name="other" />s.
            </summary>
      <param name="other">Solution instance to compare to.</param>
      <returns>If the objective values are compared, the return value indicates dominance of solution quality (i.e. zero indicates indifference).</returns>
      <exception cref="T:System.NotSupportedException">If this solution instance has status <c>NoSolutionValues</c>.</exception>
      <exception cref="T:System.ArgumentException">If <paramref name="other" /> has status <c>NoSolutionValues</c> or the solutions' objective names do not fit to each other.</exception>
    </member>
    <member name="M:Optimization.Interfaces.ISolution.Equals(System.Collections.Generic.IDictionary{System.String,System.Double})">
      <summary>
            Indicates whether the variable values of this solution instance are equal to <paramref name="otherVariableValues" />.
            </summary>
      <param name="otherVariableValues">The variable values to compare to.</param>
      <returns />
      <exception cref="T:System.NotSupportedException">If this solution instance has status <c>NoSolutionValues</c>.</exception>
      <exception cref="T:System.ArgumentException">If the solutions' variable names do not fit to each other.</exception>
    </member>
    <member name="M:Optimization.Interfaces.ISolution.Equals(Optimization.Solution)">
      <summary>
            Indicates whether the objective values of this solution instance are equal to <paramref name="other" />s.
            </summary>
      <param name="other">The <see cref="T:Optimization.Solution" /> to compare to.</param>
      <returns />
      <exception cref="T:System.InvalidOperationException">If this solution instance has status <c>NoSolutionValues</c>.</exception>
      <exception cref="T:System.ArgumentException">If <paramref name="other" /> has status <c>NoSolutionValues</c> or the solutions' objective names do not fit to each other.</exception>
    </member>
    <member name="M:Optimization.Interfaces.ISolution.ClearValues">
      <summary>
            Removes the variable values and objective values from this solution instance and sets the status to <c>NoSolutionValues</c>.
            </summary>
    </member>
    <member name="M:Optimization.Interfaces.ISolution.GetVariableValue(System.String)">
      <summary>
            Returns the solution value of the variable named <paramref name="name" />, or <c>null</c> if the status of this solution instance is <c>NoSolutionValues</c>.
            </summary>
      <param name="name">Name of the variable.</param>
      <returns />
    </member>
    <member name="M:Optimization.Interfaces.ISolution.GetObjectiveValue(System.String)">
      <summary>
            Returns the solution value of the objective named <paramref name="name" />, or <c>null</c> if the status of this solution instance is <c>NoSolutionValues</c>.
            </summary>
      <param name="name">Name of the objective.</param>
      <returns />
    </member>
    <member name="P:Optimization.Interfaces.ISolution.Status">
      <summary>
            Status of this solution instance.
            </summary>
    </member>
    <member name="P:Optimization.Interfaces.ISolution.ModelName">
      <summary>
            Gets the name of the model.
            </summary>
      <value>The name of the model.</value>
    </member>
    <member name="P:Optimization.Interfaces.ISolution.ModelStatus">
      <summary>
            Gets the model status.
            </summary>
      <value>The model status.</value>
    </member>
    <member name="P:Optimization.Interfaces.ISolution.OverallWallTime">
      <summary>
            Gets the overall wall time.
            </summary>
      <value>The overall wall time.</value>
    </member>
    <member name="P:Optimization.Interfaces.ISolution.VariableValues">
      <summary>
            Unique name and solution value for each variable in the solved model instance, or <c>null</c> if the status of this solution instance is <c>NoSolutionValues</c>.
            </summary>
    </member>
    <member name="P:Optimization.Interfaces.ISolution.DualVariableValues">
      <summary>
            Unique name and solution value for each dual variable in the solved model instance, or <c>null</c> if the status of this solution instance is <c>NoSolutionValues</c>.
            </summary>
    </member>
    <member name="P:Optimization.Interfaces.ISolution.ObjectiveValues">
      <summary>
            Unique name and solution value for each objective in the solved model instance, or <c>null</c> if the status of this solution instance is <c>NoSolutionValues</c>.
            </summary>
    </member>
    <member name="P:Optimization.Interfaces.ISolution.ConflictingSet">
      <summary>
            Gets the conflicting set.
            </summary>
    </member>
    <member name="T:Optimization.Solver.ICanSolve`2">
      <summary>
            Indicates that this solver can solve models of type M and return solutions of type S
            </summary>
      <typeparam name="M">The model type</typeparam>
      <typeparam name="S">The solution type</typeparam>
    </member>
    <member name="M:Optimization.Solver.ICanSolve`2.Solve(`0,System.Collections.Generic.IDictionary{System.String,System.Double})">
      <summary>
            Solves the given <paramref name="model" />.
            Optimizes if <paramref name="model" /> contains at least one objective.
            </summary>
      <param name="model">The model to solve.</param>
      <param name="variableValues">Initial values for all or a subset of variables in <paramref name="model" />.</param>
      <returns />
      <exception cref="T:System.NotSupportedException">If this solver instance not supports solving.</exception>
      <exception cref="T:System.InvalidOperationException">If this solver instance is busy.</exception>
      <exception cref="T:System.ArgumentException">If this solver instance cannot handle the kind of <paramref name="model" />.</exception>
    </member>
    <member name="T:Optimization.Solver.IAbortable">
      <summary>
            If a solver can be aborted it should implement this interface
            </summary>
    </member>
    <member name="M:Optimization.Solver.IAbortable.Abort">
      <summary>
            If this solver instance is busy abort the run as soon as possible, or do nothing if this solver instance is not busy.
            </summary>
      <exception cref="T:System.NotSupportedException">If this solver instance not supports aborting.</exception>
    </member>
    <member name="T:Optimization.Interfaces.ISolver">
      <summary>
            Represents a solver instance for mathematical programming problems.
            </summary>
      <author>skramkowski</author>
    </member>
    <member name="M:Optimization.Interfaces.ISolver.ClearLastModel">
      <summary>
            Deletes the internal datastructures of this solver instance.
            </summary>
      <exception cref="T:System.InvalidOperationException">If this solver instance is busy.</exception>
    </member>
    <member name="P:Optimization.Interfaces.ISolver.Configuration">
      <summary>
            The configuration of this solver instance.
            </summary>
    </member>
    <member name="P:Optimization.Interfaces.ISolver.IsBusy">
      <summary>
            Is this solver instance busy?
            </summary>
    </member>
    <member name="T:Optimization.Interfaces.ISolverConfiguration">
      <summary>
            Configures certain behaviors of a solver
            </summary>
    </member>
    <member name="P:Optimization.Interfaces.ISolverConfiguration.UseHeuristicCallback">
      <summary>
            Indicates if the solver should activate its provided HeuristicCallback
            This will make the solver use injected solutions from other solvers
            </summary>
    </member>
    <member name="P:Optimization.Interfaces.ISolverConfiguration.CallbackEndpoint">
      <summary>
            This endpoint will be used to enable communication between solvers
            </summary>
    </member>
    <member name="T:Optimization.Interfaces.ITerm">
      <summary>
            Describes the abilities of a Term
            </summary>
    </member>
    <member name="P:Optimization.Interfaces.ITerm.Factor">
      <summary>
            Gets the factor.
            </summary>
    </member>
    <member name="P:Optimization.Interfaces.ITerm.Variable">
      <summary>
            Gets the variable.
            </summary>
    </member>
    <member name="T:Optimization.Interfaces.ITimes">
      <summary>
            Describes the interface for the times operation
            </summary>
    </member>
    <member name="T:Optimization.ModelBehavior">
      <summary>
            Describes the behavior of a model when adding constraints
            </summary>
    </member>
    <member name="F:Optimization.ModelBehavior.Manual">
      <summary>
            Variables in a constraint will not be added to the model, you need to do this manually beforehand
            </summary>
    </member>
    <member name="F:Optimization.ModelBehavior.Auto">
      <summary>
            Variables in a constraint will be added to the model automatically
            </summary>
    </member>
    <member name="T:Optimization.ObjectiveSense">
      <summary>
            Sense of an <see cref="T:Optimization.Interfaces.IObjective" />.
            </summary>
    </member>
    <member name="F:Optimization.ObjectiveSense.Minimize">
      <summary />
    </member>
    <member name="F:Optimization.ObjectiveSense.Maximize">
      <summary />
    </member>
    <member name="T:Optimization.Solution">
      <summary>
            Represents a solution of an <see cref="T:Optimization.Interfaces.IModel" />.
            </summary>
      <author>fseidel, skramkowski</author>
    </member>
    <member name="F:Optimization.Solution._modelName">
      <summary>
            Name of the solved model instance.
            </summary>
    </member>
    <member name="F:Optimization.Solution._modelStatus">
      <summary>
            Status of the solved model instance.
            </summary>
    </member>
    <member name="F:Optimization.Solution._overallWallTime">
      <summary>
            Overall wall clock time taken for solving.
            </summary>
    </member>
    <member name="M:Optimization.Solution.#ctor(System.String,System.TimeSpan,Optimization.Solver.ModelStatus,Optimization.Solver.SolutionStatus,System.Collections.Generic.IDictionary{System.String,System.Double},System.Collections.Generic.IDictionary{System.String,System.Double},System.Collections.Generic.IDictionary{System.String,System.Double},Optimization.Interfaces.Solver.IConflictingSet)">
      <summary>
            Creates a new solution instance.
            </summary>
      <param name="modelName">Name of the solved model instance.</param>
      <param name="overallWallTime">Overall wall clock time taken for solving.</param>
      <param name="modelStatus">Status of the solved model instance.</param>
      <param name="status">Status of the new solution instance.</param>
      <param name="variableValues">Name and solution value for each variable in the solved model instance, or <c>null</c> if the status of this solution instance is <c>NoSolutionValues</c>.</param>
      <param name="dualVariableValues">Name and solution value for each dual variable in the solved model instance, or <c>null</c> if the status of this solution instance is <c>NoSolutionValues</c>.</param>
      <param name="objectiveValues">Name and solution value for each objective in the solved model instance, or <c>null</c> if the status of this solution instance is <c>NoSolutionValues</c>.</param>
    </member>
    <member name="M:Optimization.Solution.CompareTo(Optimization.Solution)">
      <summary>
            Compares the objective values of this solution instance to <paramref name="other" />s.
            </summary>
      <param name="other">Solution instance to compare to.</param>
      <returns>If the objective values are compared, the return value indicates dominance of solution quality (i.e. zero indicates indifference).</returns>
      <exception cref="T:System.NotSupportedException">If this solution instance has status <c>NoSolutionValues</c>.</exception>
      <exception cref="T:System.ArgumentException">If <paramref name="other" /> has status <c>NoSolutionValues</c> or the solutions' objective names do not fit to each other.</exception>
    </member>
    <member name="M:Optimization.Solution.Equals(System.Collections.Generic.IDictionary{System.String,System.Double})">
      <summary>
            Indicates whether the variable values of this solution instance are equal to <paramref name="otherVariableValues" />.
            </summary>
      <param name="otherVariableValues">The variable values to compare to.</param>
      <returns />
      <exception cref="T:System.NotSupportedException">If this solution instance has status <c>NoSolutionValues</c>.</exception>
      <exception cref="T:System.ArgumentException">If the solutions' variable names do not fit to each other.</exception>
    </member>
    <member name="M:Optimization.Solution.Equals(Optimization.Solution)">
      <summary>
            Indicates whether the objective values of this solution instance are equal to <paramref name="other" />s.
            </summary>
      <param name="other">The <see cref="T:Optimization.Solution" /> to compare to.</param>
      <returns />
      <exception cref="T:System.InvalidOperationException">If this solution instance has status <c>NoSolutionValues</c>.</exception>
      <exception cref="T:System.ArgumentException">If <paramref name="other" /> has status <c>NoSolutionValues</c> or the solutions' objective names do not fit to each other.</exception>
    </member>
    <member name="M:Optimization.Solution.ClearValues">
      <summary>
            Removes the variable values and objective values from this solution instance and sets the status to <c>NoSolutionValues</c>.
            </summary>
    </member>
    <member name="M:Optimization.Solution.GetVariableValue(System.String)">
      <summary>
            Returns the solution value of the variable named <paramref name="name" />, or <c>null</c> if the status of this solution instance is <c>NoSolutionValues</c>.
            </summary>
      <param name="name">Name of the variable.</param>
      <returns />
    </member>
    <member name="M:Optimization.Solution.GetObjectiveValue(System.String)">
      <summary>
            Returns the solution value of the objective named <paramref name="name" />, or <c>null</c> if the status of this solution instance is <c>NoSolutionValues</c>.
            </summary>
      <param name="name">Name of the objective.</param>
      <returns />
    </member>
    <member name="P:Optimization.Solution.ConflictingSet">
      <summary>
            Gets the conflicting set.
            </summary>
    </member>
    <member name="P:Optimization.Solution.Status">
      <summary>
            Status of this solution instance.
            </summary>
    </member>
    <member name="P:Optimization.Solution.ModelName">
      <summary>
            Gets the name of the model.
            </summary>
      <value>The name of the model.</value>
    </member>
    <member name="P:Optimization.Solution.ModelStatus">
      <summary>
            Gets the model status.
            </summary>
      <value>The model status.</value>
    </member>
    <member name="P:Optimization.Solution.OverallWallTime">
      <summary>
            Gets the overall wall time.
            </summary>
      <value>The overall wall time.</value>
    </member>
    <member name="P:Optimization.Solution.VariableValues">
      <summary>
            Unique name and solution value for each variable in the solved model instance, or <c>null</c> if the status of this solution instance is <c>NoSolutionValues</c>.
            </summary>
    </member>
    <member name="P:Optimization.Solution.DualVariableValues">
      <summary>
            Unique name and solution value for each dual variable in the solved model instance, or <c>null</c> if the status of this solution instance is <c>NoSolutionValues</c>.
            </summary>
    </member>
    <member name="P:Optimization.Solution.ObjectiveValues">
      <summary>
            Unique name and solution value for each objective in the solved model instance, or <c>null</c> if the status of this solution instance is <c>NoSolutionValues</c>.
            </summary>
    </member>
    <member name="P:Optimization.Interfaces.Solver.IConflictingSet.VariablesUB">
      <summary>
            Gets the variables for which the upper bounds are conflicting
            </summary>
    </member>
    <member name="P:Optimization.Interfaces.Solver.IConflictingSet.VariablesLB">
      <summary>
            Gets the variables for which the lower bounds are conflicting.
            </summary>
    </member>
    <member name="P:Optimization.Interfaces.Solver.IConflictingSet.ConstraintsLB">
      <summary>
            Gets the conflicting constraints where the lower bound is in conflict.
            </summary>
    </member>
    <member name="P:Optimization.Interfaces.Solver.IConflictingSet.ConstraintsUB">
      <summary>
            Gets the conflicting constraints where the upper bound is in conflict.
            </summary>
    </member>
    <member name="P:Optimization.Interfaces.Solver.IConflictingSet.SOS">
      <summary>
            Gets the conflicting SOS sets.
            </summary>
    </member>
    <member name="M:Optimization.Interfaces.Solver.ConflictingSet.#ctor(System.Collections.Generic.IEnumerable{Optimization.Interfaces.IVariable},System.Collections.Generic.IEnumerable{Optimization.Interfaces.IVariable},System.Collections.Generic.IEnumerable{Optimization.Interfaces.IConstraint},System.Collections.Generic.IEnumerable{Optimization.Interfaces.IConstraint},System.Collections.Generic.IEnumerable{System.Collections.Generic.IDictionary{Optimization.Interfaces.IVariable,System.Double}})">
      <summary>
            Initializes a new instance of the <see cref="T:Optimization.Interfaces.Solver.ConflictingSet" /> class.
            </summary>
      <param name="variablesUb">The variables for which the upper bounds are conflicting.</param>
      <param name="variablesLb">The variables for which the lower bounds are conflicting.</param>
      <param name="constraints">The conflicting constraints.</param>
      <param name="sos">The conflicting sos stes.</param>
    </member>
    <member name="P:Optimization.Interfaces.Solver.ConflictingSet.VariablesUB">
      <summary>
            Gets the variables for which the upper bounds are conflicting
            </summary>
    </member>
    <member name="P:Optimization.Interfaces.Solver.ConflictingSet.VariablesLB">
      <summary>
            Gets the variables for which the lower bounds are conflicting.
            </summary>
    </member>
    <member name="P:Optimization.Interfaces.Solver.ConflictingSet.ConstraintsLB">
      <summary>
            Gets the conflicting constraints where the lower bound is in conflict.
            </summary>
    </member>
    <member name="P:Optimization.Interfaces.Solver.ConflictingSet.ConstraintsUB">
      <summary>
            Gets the conflicting constraints where the upper bound is in conflict.
            </summary>
    </member>
    <member name="P:Optimization.Interfaces.Solver.ConflictingSet.SOS">
      <summary>
            Gets the conflicting SOS sets.
            </summary>
    </member>
    <member name="T:Optimization.Solver.ISolverEvent">
      <summary>
            An implementing class represents an event that can be fired by a solver
            </summary>
    </member>
    <member name="T:Optimization.Solver.Events.NewIncumbentFound">
      <summary>
            This event is fired whenever a new incumbent was found during the solution process
            </summary>
    </member>
    <member name="P:Optimization.Solver.Events.NewIncumbentFound.ObjectiveValue">
      <summary>
            Gets or sets the objective value.
            </summary>
      <value>The objective value.</value>
    </member>
    <member name="P:Optimization.Solver.Events.NewIncumbentFound.IncumbentCoefficients">
      <summary>
            Gets or sets the incumbent coefficients.
            </summary>
      <value>The incumbent coefficients.</value>
    </member>
    <member name="P:Optimization.Solver.Events.NewIncumbentFound.Solver">
      <summary>
            Gets or sets the solver.
            </summary>
      <value>The solver.</value>
    </member>
    <member name="T:Optimization.Solver.ModelStatus">
      <summary>
            Status of a solved model instance.
            </summary>
    </member>
    <member name="F:Optimization.Solver.ModelStatus.Unknown">
      <summary>
            Status of the solved model instance is unknown, e.g. because the solver has too little time to prove the model instance.
            </summary>
    </member>
    <member name="F:Optimization.Solver.ModelStatus.Unbounded">
      <summary>
            The solved model instance is unbounded.
            </summary>
    </member>
    <member name="F:Optimization.Solver.ModelStatus.Infeasible">
      <summary>
            The solved model instance is infeasible.
            </summary>
    </member>
    <member name="F:Optimization.Solver.ModelStatus.Feasible">
      <summary>
            The solved model instance is feasible.
            </summary>
    </member>
    <member name="F:Optimization.Solver.ModelStatus.InfOrUnbd">
      <summary>
            The solved model instance is infeasible or unbounded.
            </summary>
    </member>
    <member name="T:Optimization.Solver.ModelTypes">
      <summary>
            Defines different types of model instances a solver can handle.
            </summary>
      <remarks>This enum will be extended as necessary if new solvers are implemented that can solve new model types.</remarks>
    </member>
    <member name="F:Optimization.Solver.ModelTypes.LinearProgram">
      <summary>
            All constraints and objectives are linear, all variables are continuous.
            </summary>
    </member>
    <member name="F:Optimization.Solver.ModelTypes.BinaryProgram">
      <summary>
            All constraints and objectives are linear, all variables are binary.
            </summary>
    </member>
    <member name="F:Optimization.Solver.ModelTypes.IntegerProgram">
      <summary>
            All constraints and objectives are linear, all variables are integer.
            </summary>
    </member>
    <member name="F:Optimization.Solver.ModelTypes.MixedIntegerProgram">
      <summary>
            All constraints and objectives are linear, all variables are integer or continuous.
            </summary>
    </member>
    <member name="F:Optimization.Solver.ModelTypes.SetPartitioningProblem">
      <summary>
            All constraints and objectives are linear, all variables are binary, all constraints have lower and upper bound equal to one, all constraint coefficients are zero or one.
            </summary>
    </member>
    <member name="F:Optimization.Solver.ModelTypes.SetCoveringProblem">
      <summary>
            All constraints and objectives are linear, all variables are binary, all constraints have lower bound equal to one and no upper bound, all constraint coefficients are zero or one.
            </summary>
    </member>
    <member name="F:Optimization.Solver.ModelTypes.SetPackingProblem">
      <summary>
            All constraints and objectives are linear, all variables are binary, all constraints have lower bound equal to zero and upper bound equal to one, all constraint coefficients are zero or one.
            </summary>
    </member>
    <member name="F:Optimization.Solver.ModelTypes.GeneralizedSetPartitioningProblem">
      <summary>
            All constraints and objectives are linear, all variables are binary, all constraints have equal lower and upper bound larger than zero, all constraints have finite and integer lower and upper bound, all constraint coefficients are zero or one.
            </summary>
    </member>
    <member name="F:Optimization.Solver.ModelTypes.GeneralizedSetCoveringProblem">
      <summary>
            All constraints and objectives are linear, all variables are binary, all constraints have finite and integer lower bound larger than zero, all constraints have no upper bound, all constraint coefficients are zero or one.
            </summary>
    </member>
    <member name="F:Optimization.Solver.ModelTypes.GeneralizedSetPackingProblem">
      <summary>
            All constraints and objectives are linear, all variables are binary, all constraints have lower bound equal to zero, all constraints have finite and integer upper bound larger than zero, all constraint coefficients are zero or one.
            </summary>
    </member>
    <member name="F:Optimization.Solver.ModelTypes.MixedIntegerQuadraticProgram">
      <summary>
            All constraints are linear, all objectives are linear or quadratic, all variables are integer or continuous.
            </summary>
    </member>
    <member name="F:Optimization.Solver.ModelTypes.MixedIntegerQuadraticConstraintProgram">
      <summary>
            All constraints and objectives are linear or quadratic, all variables are integer or continuous.
            </summary>
    </member>
    <member name="F:Optimization.Solver.ModelTypes.ContinuouslyDifferentiableProgram">
      <summary>
            All constraints and objectives are continuously differentiable, all variables are continuous.
            </summary>
    </member>
    <member name="T:Optimization.Solver.SolutionStatus">
      <summary>
            Status of a solution instance.
            </summary>
    </member>
    <member name="F:Optimization.Solver.SolutionStatus.NoSolutionValues">
      <summary>
            The solution instance contains no variable and objective values, e.g. because the solved model instance is infeasible.
            </summary>
    </member>
    <member name="F:Optimization.Solver.SolutionStatus.FeasibleContinuousRelaxation">
      <summary>
            The solution instance contains variable and objective values feasible for the continuous relaxation of the solved model instance.
            </summary>
    </member>
    <member name="F:Optimization.Solver.SolutionStatus.OptimalContinuousRelaxation">
      <summary>
            The solution instance contains variable and objective values optimal for the continuous relaxation of the solved model instance.
            </summary>
    </member>
    <member name="F:Optimization.Solver.SolutionStatus.Feasible">
      <summary>
            The solution instance contains variable and objective values feasible for the solved model instance.
            </summary>
    </member>
    <member name="F:Optimization.Solver.SolutionStatus.ProbablyLocalOptimal">
      <summary>
            The solution instance contains variable and objective values probably local optimal for the solved model instance with the used <see cref="T:Optimization.Interfaces.ISolver" />.
            </summary>
    </member>
    <member name="F:Optimization.Solver.SolutionStatus.LocalOptimal">
      <summary>
            The solution instance contains variable and objective values local optimal for the solved model instance with the used <see cref="T:Optimization.Interfaces.ISolver" />.
            </summary>
    </member>
    <member name="F:Optimization.Solver.SolutionStatus.Optimal">
      <summary>
            The solution instance contains variable and objective values optimal for the solved model instance.
            </summary>
    </member>
    <member name="T:Optimization.Solver.SolverConfiguration">
      <summary>
            Defines common parameters for <see cref="T:Optimization.Interfaces.ISolver" /> instances.
            </summary>
      <author>skramkowski</author>
    </member>
    <member name="M:Optimization.Solver.SolverConfiguration.#ctor(System.String,System.Boolean)">
      <summary>
            Initializes a new instance of the <see cref="T:Optimization.Solver.SolverConfiguration" /> class with the specified values.
            </summary>
      <param name="callbackendpoint">The callbackendpoint.</param>
      <param name="useHeuristicCallback">if set to <c>true</c> [use heuristic callback].</param>
    </member>
    <member name="M:Optimization.Solver.SolverConfiguration.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Optimization.Solver.SolverConfiguration" /> class.
            </summary>
    </member>
    <member name="P:Optimization.Solver.SolverConfiguration.UseHeuristicCallback">
      <summary>
            Indicates if the solver should activate its provided HeuristicCallback
            This will make the solver use injected solutions from other solvers
            </summary>
    </member>
    <member name="P:Optimization.Solver.SolverConfiguration.CallbackEndpoint">
      <summary>
            This endpoint will be used to enable communication between solvers
            </summary>
    </member>
    <member name="T:Optimization.SOSType">
      <summary>
            The SOS type
            </summary>
    </member>
    <member name="F:Optimization.SOSType.SOS1">
      <summary>
            A SOS1 is a set of variables in which at most one variable may be positive at an integer feasible solution.
            </summary>
    </member>
    <member name="F:Optimization.SOSType.SOS2">
      <summary>
            A SOS2 is a set of variables in which at most two variables may be positive at an integer feasible solution, and moreover, any positive variables must be adjacent in he ordering specified by the ordering values.
            </summary>
    </member>
    <member name="F:Optimization.SOSType.SOS3">
      <summary>
            The set of variables appearing in an equation with only binary variables and +1 or -1 coefficients, and a right-hand-side value of 1 - (number of -1 coefficients).  This is a special case of SOS1.
            </summary>
    </member>
    <member name="T:Optimization.VariableType">
      <summary>
            Type of a <see cref="T:Optimization.Interfaces.IVariable" />.
            </summary>
    </member>
    <member name="F:Optimization.VariableType.Integer">
      <summary>
            Whole number.
            </summary>
    </member>
    <member name="F:Optimization.VariableType.Continuous">
      <summary>
            Continuous number.
            </summary>
    </member>
    <member name="T:Optimization.Configuration.OptimizationConfigSection">
      <summary>
            The OptimizationConfigSection Configuration Section.
            </summary>
    </member>
    <member name="F:Optimization.Configuration.OptimizationConfigSection.OptimizationConfigSectionSectionName">
      <summary>
            The XML name of the OptimizationConfigSection Configuration Section.
            </summary>
    </member>
    <member name="F:Optimization.Configuration.OptimizationConfigSection.XmlnsPropertyName">
      <summary>
            The XML name of the <see cref="P:Optimization.Configuration.OptimizationConfigSection.Xmlns" /> property.
            </summary>
    </member>
    <member name="F:Optimization.Configuration.OptimizationConfigSection.ModelElementPropertyName">
      <summary>
            The XML name of the <see cref="P:Optimization.Configuration.OptimizationConfigSection.ModelElement" /> property.
            </summary>
    </member>
    <member name="F:Optimization.Configuration.OptimizationConfigSection.SolverItemsPropertyName">
      <summary>
            The XML name of the <see cref="P:Optimization.Configuration.OptimizationConfigSection.SolverItems" /> property.
            </summary>
    </member>
    <member name="M:Optimization.Configuration.OptimizationConfigSection.IsReadOnly">
      <summary>
            Gets a value indicating whether the element is read-only.
            </summary>
    </member>
    <member name="P:Optimization.Configuration.OptimizationConfigSection.Instance">
      <summary>
            Gets the OptimizationConfigSection instance.
            </summary>
    </member>
    <member name="P:Optimization.Configuration.OptimizationConfigSection.Xmlns">
      <summary>
            Gets the XML namespace of this Configuration Section.
            </summary>
      <remarks>
            This property makes sure that if the configuration file contains the XML namespace,
            the parser doesn't throw an exception because it encounters the unknown "xmlns" attribute.
            </remarks>
    </member>
    <member name="P:Optimization.Configuration.OptimizationConfigSection.ModelElement">
      <summary>
            Gets or sets defines settings for all models you will create within this application.
            </summary>
    </member>
    <member name="P:Optimization.Configuration.OptimizationConfigSection.SolverItems">
      <summary>
            Gets or sets the solvers collection allows you to specify settings for solvers you want to use within this application.
            </summary>
    </member>
    <member name="T:Optimization.Configuration.ModelElement">
      <summary>
            Defines settings for all models you will create in within this application.
            </summary>
    </member>
    <member name="F:Optimization.Configuration.ModelElement.BehaviorPropertyName">
      <summary>
            The XML name of the <see cref="P:Optimization.Configuration.ModelElement.Behavior" /> property.
            </summary>
    </member>
    <member name="M:Optimization.Configuration.ModelElement.IsReadOnly">
      <summary>
            Gets a value indicating whether the element is read-only.
            </summary>
    </member>
    <member name="P:Optimization.Configuration.ModelElement.Behavior">
      <summary>
            Gets or sets 'auto' will turn on automatic variable handling, i.e. when you add constraints and objectives the variables in them will be added automatically (default), 'manual' will turn this feature off and you need to add variables manually to the model
            </summary>
    </member>
    <member name="T:Optimization.Configuration.SolversCollection">
      <summary>
            The solvers collection allows you to specify settings for solvers you want to use within this application.
            </summary>
    </member>
    <member name="F:Optimization.Configuration.SolversCollection.SolverElementPropertyName">
      <summary>
            The XML name of the individual <see cref="T:Optimization.Configuration.SolverElement" /> instances in this collection.
            </summary>
    </member>
    <member name="M:Optimization.Configuration.SolversCollection.IsElementName(System.String)">
      <summary>
            Indicates whether the specified <see cref="T:System.Configuration.ConfigurationElement" /> exists in the <see cref="T:System.Configuration.ConfigurationElementCollection" />.
            </summary>
      <param name="elementName">The name of the element to verify.</param>
      <returns>
        <see langword="true" /> if the element exists in the collection; otherwise, <see langword="false" />.
            </returns>
    </member>
    <member name="M:Optimization.Configuration.SolversCollection.GetElementKey(System.Configuration.ConfigurationElement)">
      <summary>
            Gets the element key for the specified configuration element.
            </summary>
      <param name="element">The <see cref="T:System.Configuration.ConfigurationElement" /> to return the key for.</param>
      <returns>
            An <see cref="T:System.Object" /> that acts as the key for the specified <see cref="T:System.Configuration.ConfigurationElement" />.
            </returns>
      <requires inheritedFrom="M:System.Configuration.ConfigurationElementCollection.GetElementKey(System.Configuration.ConfigurationElement)" inheritedFromTypeName="ConfigurationElementCollection">element != null</requires>
      <ensures inheritedFrom="M:System.Configuration.ConfigurationElementCollection.GetElementKey(System.Configuration.ConfigurationElement)" inheritedFromTypeName="ConfigurationElementCollection">Contract.Result&lt;object&gt;() != null</ensures>
    </member>
    <member name="M:Optimization.Configuration.SolversCollection.CreateNewElement">
      <summary>
            Creates a new <see cref="T:Optimization.Configuration.SolverElement" />.
            </summary>
      <returns>
            A new <see cref="T:Optimization.Configuration.SolverElement" />.
            </returns>
      <ensures inheritedFrom="M:System.Configuration.ConfigurationElementCollection.CreateNewElement" inheritedFromTypeName="ConfigurationElementCollection">Contract.Result&lt;ConfigurationElement&gt;() != null</ensures>
    </member>
    <member name="M:Optimization.Configuration.SolversCollection.Add(Optimization.Configuration.SolverElement)">
      <summary>
            Adds the specified <see cref="T:Optimization.Configuration.SolverElement" /> to the <see cref="T:System.Configuration.ConfigurationElementCollection" />.
            </summary>
      <param name="solver">The <see cref="T:Optimization.Configuration.SolverElement" /> to add.</param>
    </member>
    <member name="M:Optimization.Configuration.SolversCollection.Remove(Optimization.Configuration.SolverElement)">
      <summary>
            Removes the specified <see cref="T:Optimization.Configuration.SolverElement" /> from the <see cref="T:System.Configuration.ConfigurationElementCollection" />.
            </summary>
      <param name="solver">The <see cref="T:Optimization.Configuration.SolverElement" /> to remove.</param>
      <requires>solver!=null</requires>
    </member>
    <member name="M:Optimization.Configuration.SolversCollection.GetItemAt(System.Int32)">
      <summary>
            Gets the <see cref="T:Optimization.Configuration.SolverElement" /> at the specified index.
            </summary>
      <param name="index">The index of the <see cref="T:Optimization.Configuration.SolverElement" /> to retrieve.</param>
    </member>
    <member name="M:Optimization.Configuration.SolversCollection.GetItemByKey(System.String)">
      <summary>
            Gets the <see cref="T:Optimization.Configuration.SolverElement" /> with the specified key.
            </summary>
      <param name="name">The key of the <see cref="T:Optimization.Configuration.SolverElement" /> to retrieve.</param>
    </member>
    <member name="M:Optimization.Configuration.SolversCollection.IsReadOnly">
      <summary>
            Gets a value indicating whether the element is read-only.
            </summary>
    </member>
    <member name="P:Optimization.Configuration.SolversCollection.CollectionType">
      <summary>
            Gets the type of the <see cref="T:System.Configuration.ConfigurationElementCollection" />.
            </summary>
      <returns>The <see cref="T:System.Configuration.ConfigurationElementCollectionType" /> of this collection.</returns>
    </member>
    <member name="P:Optimization.Configuration.SolversCollection.ElementName">
      <summary>
            Gets the name used to identify this collection of elements
            </summary>
      <getter>
        <ensures inheritedFrom="M:System.Configuration.ConfigurationElementCollection.get_ElementName" inheritedFromTypeName="ConfigurationElementCollection">Contract.Result&lt;string&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Optimization.Configuration.SolversCollection.Item(System.Int32)">
      <summary>
            Gets the <see cref="T:Optimization.Configuration.SolverElement" /> at the specified index.
            </summary>
      <param name="index">The index of the <see cref="T:Optimization.Configuration.SolverElement" /> to retrieve.</param>
    </member>
    <member name="P:Optimization.Configuration.SolversCollection.Item(System.Object)">
      <summary>
            Gets the <see cref="T:Optimization.Configuration.SolverElement" /> with the specified key.
            </summary>
      <param name="name">The key of the <see cref="T:Optimization.Configuration.SolverElement" /> to retrieve.</param>
    </member>
    <member name="T:Optimization.Configuration.SolverElement">
      <summary>
            Specifies settings for a particular solver.
            </summary>
    </member>
    <member name="F:Optimization.Configuration.SolverElement.NamePropertyName">
      <summary>
            The XML name of the <see cref="P:Optimization.Configuration.SolverElement.Name" /> property.
            </summary>
    </member>
    <member name="F:Optimization.Configuration.SolverElement.PathPropertyName">
      <summary>
            The XML name of the <see cref="P:Optimization.Configuration.SolverElement.Path" /> property.
            </summary>
    </member>
    <member name="M:Optimization.Configuration.SolverElement.IsReadOnly">
      <summary>
            Gets a value indicating whether the element is read-only.
            </summary>
    </member>
    <member name="P:Optimization.Configuration.SolverElement.Name">
      <summary>
            Gets or sets the name of a specific solver ("Cplex" is the default)
            </summary>
    </member>
    <member name="P:Optimization.Configuration.SolverElement.Path">
      <summary>
            Gets or sets specifies the path to the native dll of this solver.  You can also use relative paths, like "..\..\cplex.dll"
            </summary>
    </member>
    <member name="T:Optimization.Solver.Cplex.CplexSolver">
      <summary>
            Represents a CPLEX solver instance for mathematical programming problems.
            </summary>
      <author>larsbeck, floriani</author>
    </member>
    <member name="M:Optimization.Solver.Cplex.CplexSolver.#ctor(Optimization.Interfaces.ISolverConfiguration)">
      <summary>
            Initializes a new instance of the <see cref="T:Optimization.Solver.Cplex.CplexSolver" /> class.
            </summary>
      <param name="configuration">The configuration.</param>
    </member>
    <member name="M:Optimization.Solver.Cplex.CplexSolver.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Optimization.Solver.Cplex.CplexSolver" /> class.
            </summary>
    </member>
    <member name="M:Optimization.Solver.Cplex.CplexSolver.Abort">
      <summary>
            If this solver instance is busy abort the run as soon as possible, or do nothing if this solver instance is not busy.
            </summary>
    </member>
    <member name="M:Optimization.Solver.Cplex.CplexSolver.ClearLastModel">
      <summary>
            Deletes the internal datastructures of this solver instance.
            </summary>
      <exception cref="T:System.InvalidOperationException">If this solver instance is busy.</exception>
    </member>
    <member name="M:Optimization.Solver.Cplex.CplexSolver.Solve(Optimization.Interfaces.IModel,System.Collections.Generic.IDictionary{System.String,System.Double})">
      <summary>
            Solves the given <paramref name="model" />.
            Optimizes if <paramref name="model" /> contains at least one objective.
            </summary>
      <param name="model">The model to solve.</param>
      <param name="variableValues">Initial values for all or a subset of variables in <paramref name="model" />.</param>
      <returns>
      </returns>
      <exception cref="T:System.NotSupportedException">If this solver instance not supports solving.</exception>
      <exception cref="T:System.InvalidOperationException">If this solver instance is busy.</exception>
      <exception cref="T:System.ArgumentException">If this solver instance cannot handle the kind of <paramref name="model" />.</exception>
    </member>
    <member name="P:Optimization.Solver.Cplex.CplexSolver.Configuration">
      <summary>
            The configuration of this solver instance.
            </summary>
    </member>
    <member name="P:Optimization.Solver.Cplex.CplexSolver.IsBusy">
      <summary>
            Is this solver instance busy?
            </summary>
    </member>
    <member name="T:Optimization.Solver.Cplex.CplexSolverConfiguration">
      <summary>
            Configuration for a Cplex solver instance
            </summary>
    </member>
    <member name="M:Optimization.Solver.Cplex.CplexSolverConfiguration.#ctor(System.String,System.Boolean)">
      <summary>
            Initializes a new instance of the <see cref="T:Optimization.Solver.Cplex.CplexSolverConfiguration" /> class.
            </summary>
      <param name="callbackendpoint">The callbackendpoint.</param>
      <param name="useHeuristicCallback">if set to <c>true</c> [use heuristic callback].</param>
    </member>
    <member name="M:Optimization.Solver.Cplex.CplexSolverConfiguration.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Optimization.Solver.Cplex.CplexSolverConfiguration" /> class.
            </summary>
    </member>
    <member name="T:Optimization.Solver.Cplex.NumExprVisitor">
      <summary>
            This is a helper class to create an expression for the CPLEXSolver visiting all nodes of an Optimization.Model.IExpression
            </summary>
    </member>
    <member name="M:Optimization.Solver.Cplex.NumExprVisitor.#ctor(System.Collections.Generic.Dictionary{System.String,ILOG.Concert.INumVar},ILOG.CPLEX.Cplex)">
      <summary>
            Initializes a new instance of of the <see cref="T:Optimization.Solver.Cplex.NumExprVisitor" /> class.
            Constructor used for creating an expression-visitor for CPLEX.
            </summary>
      <param name="variables">All variables of a model in CPLEX</param>
      <param name="cplex">The corresponding model in CPLEX</param>
    </member>
    <member name="M:Optimization.Solver.Cplex.NumExprVisitor.VisitITerm(Optimization.Interfaces.ITerm)">
      <summary>
            Returns a new expression for CPLEX representing a ITerm
            </summary>
      <param name="ITerm">An Optimization.Model.IExpression as ITerm</param>
      <returns>The expression representing a ITerm</returns>
    </member>
    <member name="M:Optimization.Solver.Cplex.NumExprVisitor.VisitConstant(Optimization.Interfaces.IConstantExpression)">
      <summary>
            Returns a new expression for CPLEX representing a constant
            </summary>
      <param name="IConstantExpression">An Optimization.Model.IExpression as IConstantExpression</param>
      <returns>The expression representing a constant</returns>
    </member>
    <member name="M:Optimization.Solver.Cplex.NumExprVisitor.VisitTimes(Optimization.Interfaces.ITimes)">
      <summary>
            Returns an expression for CPLEX created as product of a factor and an expresions(INumExpr) or as quadratic expression.
            There is no general times operator supported for expressions in CPLEX.
            </summary>
      <param name="times">An Optimization.Model.Expression as Operator.Times</param>
      <returns>The expression for CPLEX</returns>
    </member>
    <member name="M:Optimization.Solver.Cplex.NumExprVisitor.VisitPlus(Optimization.Interfaces.IPlus)">
      <summary>
            Returns a new expression for CPLEX created as sum of all operands(INumExpr)
            </summary>
      <param name="plus">An Optimization.Model.Expression as Operator.Plus</param>
      <returns>The expression for CPLEX</returns>
    </member>
    <member name="M:Optimization.Solver.Cplex.NumExprVisitor.TimesScalar(System.Double,Optimization.Interfaces.IExpression)">
      <summary>
            Builds up an expression consisting of an expression * factor
            </summary>
      <param name="factor">A constant</param>
      <param name="expr">An Optimization.Model.IExpression</param>
      <returns>The expression for CPLEX</returns>
    </member>
    <member name="M:Optimization.Solver.Cplex.NumExprVisitor.TimesQuadratic(System.Double,ILOG.Concert.INumVar[])">
      <summary>
            Builds up an expression, which is possibly quadratic: factor * var1 (* var2)
            </summary>
      <param name="factor">A constant</param>
      <param name="vars">The variables of the quadratic expression</param>
      <returns>The quadratic expression for CPLEX</returns>
    </member>
    <member name="T:Optimization.Solver.Cplex.P2PCplexSolver">
      <summary>
            The wrapper for Cplex as as P2P node
            </summary>
    </member>
    <member name="M:Optimization.Solver.Cplex.P2PCplexSolver.#ctor(Optimization.Interfaces.ISolverConfiguration)">
      <summary>
            Initializes a new instance of the <see cref="T:Optimization.Solver.Cplex.P2PCplexSolver" /> class.
            </summary>
      <param name="configuration">The configuration.</param>
    </member>
    <member name="M:Optimization.Solver.Cplex.P2PCplexSolver.HandleEvent(Optimization.Solver.Events.NewIncumbentFound)">
      <summary>
            Handles the event.
            </summary>
      <param name="solverEvent">The solver event.</param>
    </member>
    <member name="M:Optimization.Solver.Cplex.P2PCplexSolver.Solve(Optimization.Interfaces.IModel,System.Collections.Generic.IDictionary{System.String,System.Double})">
      <summary>
            Solves the specified model.
            </summary>
      <param name="model">The model.</param>
      <param name="variableValues">The variable values.</param>
    </member>
    <member name="M:Optimization.Solver.Cplex.P2PCplexSolver.Join(System.Guid)">
      <summary>
            A solver joins the mesh and communicates its id
            </summary>
      <param name="id">The id.</param>
    </member>
    <member name="M:Optimization.Solver.Cplex.P2PCplexSolver.Leave(System.Guid)">
      <summary>
            A solver leaves the mesh and communicates its id
            </summary>
      <param name="id">The id.</param>
    </member>
    <member name="M:Optimization.Solver.Cplex.P2PCplexSolver.AskForNodes(System.Guid)">
      <summary>
            A solver that has no more work and needs a node to continue calls this method to find all busy solvers that have nodes available
            </summary>
    </member>
    <member name="M:Optimization.Solver.Cplex.P2PCplexSolver.JoinReply(System.Guid)">
      <summary>
            All solvers communicate thir ids to a joining solver.
            </summary>
      <param name="id">The id.</param>
    </member>
    <member name="M:Optimization.Solver.Cplex.P2PCplexSolver.AskForNodesReplyPositive(System.Guid)">
      <summary>
            A solver calls this method if he has nodes available in its nodelist
            </summary>
    </member>
    <member name="M:Optimization.Solver.Cplex.P2PCplexSolver.AskForNodesReplyNegative">
      <summary>
            A solver calls this method if he has no nodes available in its nodelist
            </summary>
    </member>
    <member name="M:Optimization.Solver.Cplex.P2PCplexSolver.InitializeMesh">
      <summary>
            Initializes the mesh.
            </summary>
    </member>
    <member name="M:Optimization.Solver.Cplex.P2PCplexSolver.RequestNode(System.Guid)">
      <summary>
            A solver that has no more work and needs a node to continue calls this method on one specific solver
            </summary>
    </member>
    <member name="M:Optimization.Solver.Cplex.P2PCplexSolver.NodeReply(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{Optimization.Interfaces.IConstraint}})">
      <summary>
            This list of IConstraints will be used to restrict the solver to this one node and its subnodes
            </summary>
      <param name="nodes">The node.</param>
    </member>
    <member name="T:Optimization.Solver.Gurobi.GRBExprVisitor">
      <summary>
            This is a helper class to create an expression for the GurobiSolver visiting all nodes of an Optimization.Model.IExpression
            </summary>
    </member>
    <member name="M:Optimization.Solver.Gurobi.GRBExprVisitor.#ctor(System.Collections.Generic.Dictionary{System.String,Gurobi.GRBVar})">
      <summary>
            Initializes a new instance of of the <see cref="T:Optimization.Solver.Gurobi.GRBExprVisitor" /> class.
            Constructor used for creating an expression-visitor for Gurobi.
            </summary>
      <param name="variables">All variables of a model in Gurobi</param>
    </member>
    <member name="M:Optimization.Solver.Gurobi.GRBExprVisitor.VisitTerm(Optimization.Interfaces.ITerm)">
      <summary>
            Returns a new expression for Gurobi representing a term
            </summary>
      <param name="term">An Optimization.Model.IExpression as Term</param>
      <returns>The expression representing a term</returns>
    </member>
    <member name="M:Optimization.Solver.Gurobi.GRBExprVisitor.VisitConstant(Optimization.Interfaces.IConstantExpression)">
      <summary>
            Returns a new expression for Gurobi representing a constant
            </summary>
      <param name="constantExpression">An Optimization.Model.IExpression as ConstantExpression</param>
      <returns>The expression representing a constant</returns>
    </member>
    <member name="M:Optimization.Solver.Gurobi.GRBExprVisitor.VisitTimes(Optimization.Interfaces.ITimes)">
      <summary>
            Returns an expression for Gurobi created as product of a factor and linear expresions(GRBLinExpr) or terms
            There is no general times operator supported for linear expressions in Gurobi.
            </summary>
      <param name="times">An Optimization.Model.Expression as Operator.Times</param>
      <returns>The expression for Gurobi</returns>
    </member>
    <member name="M:Optimization.Solver.Gurobi.GRBExprVisitor.VisitPlus(Optimization.Interfaces.IPlus)">
      <summary>
            Returns a new expression for Gurobi created as sum of all operands(GRBLinExpr)
            </summary>
      <param name="plus">An Optimization.Model.Expression as Operator.Plus</param>
      <returns>The expression for Gurobi</returns>
    </member>
    <member name="M:Optimization.Solver.Gurobi.GRBExprVisitor.TimesScalar(System.Double,Optimization.Interfaces.IExpression)">
      <summary>
            Builds up an expression consisting of an expression * factor
            </summary>
      <param name="factor">A constant</param>
      <param name="expr">An Optimization.Model.IExpression</param>
      <returns>The expression for Gurobi</returns>
    </member>
    <member name="M:Optimization.Solver.Gurobi.GRBExprVisitor.TimesQuadratic(System.Double,Gurobi.GRBVar[])">
      <summary>
            Builds up an expression, which is possibly quadratic: factor * var1 (* var2)
            </summary>
      <param name="factor">A constant</param>
      <param name="vars">The variables of the quadratic expression</param>
      <returns>The quadratic expression</returns>
    </member>
    <member name="T:Optimization.Solver.Gurobi.GurobiSolver">
      <summary>
            A wrapper class to access Gurobi as a solver
            </summary>
    </member>
    <member name="M:Optimization.Solver.Gurobi.GurobiSolver.#ctor(Optimization.Solver.Gurobi.GurobiSolverConfiguration)">
      <summary>
            Initializes a new instance of the <see cref="T:Optimization.Solver.Gurobi.GurobiSolver" /> class.
            </summary>
      <param name="configuration">The configuration.</param>
    </member>
    <member name="M:Optimization.Solver.Gurobi.GurobiSolver.HandleEvent(Optimization.Solver.Events.NewIncumbentFound)">
      <summary>
            Handles the NewIncumbentFound event
            </summary>
      <param name="solverEvent">The solver event.</param>
    </member>
    <member name="M:Optimization.Solver.Gurobi.GurobiSolver.ClearLastModel">
      <summary>
            Deletes the internal datastructures of this solver instance.
            </summary>
      <exception cref="T:System.InvalidOperationException">If this solver instance is busy.</exception>
    </member>
    <member name="M:Optimization.Solver.Gurobi.GurobiSolver.Solve(Optimization.Interfaces.IModel,System.Collections.Generic.IDictionary{System.String,System.Double})">
      <summary>
            Solves the specified model.
            </summary>
      <param name="model">The model.</param>
      <param name="variableValues">The variable values.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Optimization.Solver.Gurobi.GurobiSolver.Abort">
      <summary>
            If this solver instance is busy abort the run as soon as possible, or do nothing if this solver instance is not busy.
            </summary>
      <exception cref="T:System.NotSupportedException">If this solver instance not supports aborting.</exception>
    </member>
    <member name="P:Optimization.Solver.Gurobi.GurobiSolver.Configuration">
      <summary>
            The configuration of this solver instance.
            </summary>
      <value>
      </value>
    </member>
    <member name="P:Optimization.Solver.Gurobi.GurobiSolver.IsBusy">
      <summary>
            Is this solver instance busy?
            </summary>
      <value>
      </value>
    </member>
    <member name="T:Optimization.Solver.Gurobi.GurobiSolverConfiguration">
      <summary>
            The configuration for Gurobi
            </summary>
    </member>
    <member name="M:Optimization.Solver.Gurobi.GurobiSolverConfiguration.#ctor(System.String,System.Boolean,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Optimization.Solver.Gurobi.GurobiSolverConfiguration" /> class with the specified values.
            </summary>
      <param name="callbackendpoint">The callbackendpoint.</param>
      <param name="useHeuristicCallback">if set to <c>true</c> [use heuristic callback].</param>
      <param name="configFile">The config file.</param>
    </member>
    <member name="M:Optimization.Solver.Gurobi.GurobiSolverConfiguration.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Optimization.Solver.Gurobi.GurobiSolverConfiguration" /> class.
            </summary>
    </member>
    <member name="P:Optimization.Solver.Gurobi.GurobiSolverConfiguration.ConfigFile">
      <summary>
            Gets or sets the config file.
            </summary>
      <value>The config file.</value>
    </member>
    <member name="T:Optimization.Solver.Gurobi.SolverStatus">
      <summary>
            The Status of the Gurobi solver
            </summary>
    </member>
    <member name="F:Optimization.Solver.Gurobi.SolverStatus.Cutoff">
      <summary>
            Cutoff
            </summary>
    </member>
    <member name="F:Optimization.Solver.Gurobi.SolverStatus.Infeasible">
      <summary>
            Infeasible
            </summary>
    </member>
    <member name="F:Optimization.Solver.Gurobi.SolverStatus.InfOrUnbd">
      <summary>
            Infinity or Unbounded
            </summary>
    </member>
    <member name="F:Optimization.Solver.Gurobi.SolverStatus.Interrupted">
      <summary>
            Interrupted
            </summary>
    </member>
    <member name="F:Optimization.Solver.Gurobi.SolverStatus.IterationLimit">
      <summary>
            IterationLimit
            </summary>
    </member>
    <member name="F:Optimization.Solver.Gurobi.SolverStatus.Loaded">
      <summary>
            Loaded
            </summary>
    </member>
    <member name="F:Optimization.Solver.Gurobi.SolverStatus.NodeLimit">
      <summary>
            NodeLimit
            </summary>
    </member>
    <member name="F:Optimization.Solver.Gurobi.SolverStatus.Numeric">
      <summary>
            Numeric
            </summary>
    </member>
    <member name="F:Optimization.Solver.Gurobi.SolverStatus.Optimal">
      <summary>
            Optimal
            </summary>
    </member>
    <member name="F:Optimization.Solver.Gurobi.SolverStatus.SolutionLimit">
      <summary>
            SolutionLimit
            </summary>
    </member>
    <member name="F:Optimization.Solver.Gurobi.SolverStatus.TimeLimit">
      <summary>
            TimeLimit
            </summary>
    </member>
    <member name="F:Optimization.Solver.Gurobi.SolverStatus.Unbounded">
      <summary>
            Unbounded
            </summary>
    </member>
    <member name="F:Optimization.Solver.Gurobi.SolverStatus.Suboptimal">
      <summary>
            Suboptimal
            </summary>
    </member>
    <member name="T:Optimization.Unity.UnityServiceHostFactory">
      <summary>
            Allows to create unity service hosts.
            </summary>
    </member>
    <member name="M:Optimization.Unity.UnityServiceHostFactory.#ctor(Optimization.Unity.IUnityConfiguration)">
      <summary>
            Initializes a new instance of the <see cref="T:Optimization.Unity.UnityServiceHostFactory" /> class.
            </summary>
      <param name="unityConfiguration">The unity configuration.</param>
    </member>
    <member name="M:Optimization.Unity.UnityServiceHostFactory.CreateServiceHost(System.String,System.Uri[])">
      <summary>
            When overridden in a derived class, creates a <see cref="T:System.ServiceModel.ServiceHostBase" /> with a specific base address using custom initiation data.
            </summary>
      <param name="constructorString">The initialization data that is passed to the <see cref="T:System.ServiceModel.ServiceHostBase" /> instance being constructed by the factory.</param>
      <param name="baseAddresses">An <see cref="T:System.Array" /> of type <see cref="T:System.Uri" /> that contains the base addresses of the host.</param>
      <returns>
            The <see cref="T:System.ServiceModel.ServiceHostBase" /> object with the specified base addresses and initialized with the custom initiation data.
            </returns>
    </member>
    <member name="T:Optimization.Unity.DefaultHostFactory">
      <summary>
            This class is needed whenever you want to use the UnityServiceHostFactory with IIS
            </summary>
    </member>
    <member name="M:Optimization.Unity.DefaultHostFactory.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Optimization.Unity.DefaultHostFactory" /> class.
            </summary>
    </member>
    <member name="T:Optimization.Unity.IUnityConfiguration">
      <summary>
            Exposes a method to configure the unity container
            </summary>
    </member>
    <member name="M:Optimization.Unity.IUnityConfiguration.Configure(Microsoft.Practices.Unity.IUnityContainer)">
      <summary>
            Configures the specified container.
            </summary>
      <param name="container">The container.</param>
    </member>
    <member name="T:Optimization.Unity.Unity">
      <summary>
            A class that defines functions for unity.
            </summary>
    </member>
    <member name="M:Optimization.Unity.Unity.Configure(Optimization.Unity.IUnityConfiguration)">
      <summary>
            Configures the specified configuration.
            </summary>
      <param name="configuration">The configuration.</param>
    </member>
    <member name="M:Optimization.Unity.Unity.Resolve``1">
      <summary>
            Resolves this instance.
            </summary>
      <typeparam name="T">The type to resolve</typeparam>
      <returns>The resolved instance</returns>
    </member>
    <member name="P:Optimization.Unity.Unity.Current">
      <summary>
            Gets the current unity container
            </summary>
      <value>The current unity container</value>
    </member>
    <member name="T:Optimization.Unity.UnityInstanceProvider">
      <summary>
            An instance provider for unity
            </summary>
    </member>
    <member name="M:Optimization.Unity.UnityInstanceProvider.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Optimization.Unity.UnityInstanceProvider" /> class.
            </summary>
    </member>
    <member name="M:Optimization.Unity.UnityInstanceProvider.#ctor(System.Type)">
      <summary>
            Initializes a new instance of the <see cref="T:Optimization.Unity.UnityInstanceProvider" /> class.
            </summary>
      <param name="type">The type.</param>
    </member>
    <member name="M:Optimization.Unity.UnityInstanceProvider.GetInstance(System.ServiceModel.InstanceContext,System.ServiceModel.Channels.Message)">
      <summary>
            Returns a service object given the specified <see cref="T:System.ServiceModel.InstanceContext" /> object.
            </summary>
      <param name="instanceContext">The current <see cref="T:System.ServiceModel.InstanceContext" /> object.</param>
      <param name="message">The message that triggered the creation of a service object.</param>
      <returns>The service object.</returns>
    </member>
    <member name="M:Optimization.Unity.UnityInstanceProvider.GetInstance(System.ServiceModel.InstanceContext)">
      <summary>
            Returns a service object given the specified <see cref="T:System.ServiceModel.InstanceContext" /> object.
            </summary>
      <param name="instanceContext">The current <see cref="T:System.ServiceModel.InstanceContext" /> object.</param>
      <returns>A user-defined service object.</returns>
    </member>
    <member name="M:Optimization.Unity.UnityInstanceProvider.ReleaseInstance(System.ServiceModel.InstanceContext,System.Object)">
      <summary>
            Called when an <see cref="T:System.ServiceModel.InstanceContext" /> object recycles a service object.
            </summary>
      <param name="instanceContext">The service's instance context.</param>
      <param name="instance">The service object to be recycled.</param>
    </member>
    <member name="P:Optimization.Unity.UnityInstanceProvider.Container">
      <summary>
            Gets or sets the unity container.
            </summary>
      <value>The container.</value>
    </member>
    <member name="P:Optimization.Unity.UnityInstanceProvider.ServiceType">
      <summary>
            Gets or sets the type of the service.
            </summary>
      <value>The type of the service.</value>
    </member>
    <member name="T:Optimization.Unity.UnityServiceBehavior">
      <summary>
            A service behavior for a unity service host
            </summary>
    </member>
    <member name="M:Optimization.Unity.UnityServiceBehavior.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Optimization.Unity.UnityServiceBehavior" /> class.
            </summary>
    </member>
    <member name="M:Optimization.Unity.UnityServiceBehavior.#ctor(Microsoft.Practices.Unity.IUnityContainer)">
      <summary>
            Initializes a new instance of the <see cref="T:Optimization.Unity.UnityServiceBehavior" /> class.
            </summary>
      <param name="unity">The unity.</param>
    </member>
    <member name="M:Optimization.Unity.UnityServiceBehavior.ApplyDispatchBehavior(System.ServiceModel.Description.ServiceDescription,System.ServiceModel.ServiceHostBase)">
      <summary>
            Provides the ability to change run-time property values or insert custom extension objects such as error handlers, message or parameter interceptors, security extensions, and other custom extension objects.
            </summary>
      <param name="serviceDescription">The service description.</param>
      <param name="serviceHostBase">The host that is currently being built.</param>
    </member>
    <member name="M:Optimization.Unity.UnityServiceBehavior.AddBindingParameters(System.ServiceModel.Description.ServiceDescription,System.ServiceModel.ServiceHostBase,System.Collections.ObjectModel.Collection{System.ServiceModel.Description.ServiceEndpoint},System.ServiceModel.Channels.BindingParameterCollection)">
      <summary>
            Provides the ability to pass custom data to binding elements to support the contract implementation.
            </summary>
      <param name="serviceDescription">The service description of the service.</param>
      <param name="serviceHostBase">The host of the service.</param>
      <param name="endpoints">The service endpoints.</param>
      <param name="bindingParameters">Custom objects to which binding elements have access.</param>
    </member>
    <member name="M:Optimization.Unity.UnityServiceBehavior.Validate(System.ServiceModel.Description.ServiceDescription,System.ServiceModel.ServiceHostBase)">
      <summary>
            Provides the ability to inspect the service host and the service description to confirm that the service can run successfully.
            </summary>
      <param name="serviceDescription">The service description.</param>
      <param name="serviceHostBase">The service host that is currently being constructed.</param>
    </member>
    <member name="M:Optimization.Unity.UnityServiceBehavior.AddToHost(System.ServiceModel.ServiceHost)">
      <summary>
            Adds this service behavior to the specified host.
            </summary>
      <param name="host">The host.</param>
      <requires>host!=null</requires>
      <requires>host.Description!=null</requires>
      <requires>host.Description.Behaviors!=null</requires>
    </member>
    <member name="P:Optimization.Unity.UnityServiceBehavior.InstanceProvider">
      <summary>
            Gets or sets the instance provider.
            </summary>
      <value>The instance provider.</value>
    </member>
    <member name="T:Optimization.Unity.UnityServiceHost">
      <summary>
            A ServiceHost that uses Unity for dependency injection
            </summary>
    </member>
    <member name="M:Optimization.Unity.UnityServiceHost.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Optimization.Unity.UnityServiceHost" /> class.
            </summary>
    </member>
    <member name="M:Optimization.Unity.UnityServiceHost.#ctor(System.Type,System.Uri[])">
      <summary>
            Initializes a new instance of the <see cref="T:Optimization.Unity.UnityServiceHost" /> class.
            </summary>
      <param name="serviceType">Type of the service.</param>
      <param name="baseAddresses">The base addresses.</param>
    </member>
    <member name="M:Optimization.Unity.UnityServiceHost.OnOpening">
      <summary>
            Invoked during the transition of a communication object into the opening state.
            </summary>
    </member>
    <member name="P:Optimization.Unity.UnityServiceHost.Container">
      <summary>
            Gets or sets the container.
            </summary>
      <value>The container.</value>
    </member>
    <member name="T:Optimization.Unity.WcfUnityConfiguration">
      <summary>
            Allows configuration of a unity container in a WCF context
            </summary>
    </member>
    <member name="M:Optimization.Unity.WcfUnityConfiguration.Configure(Microsoft.Practices.Unity.IUnityContainer)">
      <summary>
            Configures the specified container.
            </summary>
      <param name="container">The container.</param>
    </member>
  </members>
</doc>